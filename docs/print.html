<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js dark">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>the-darwinia-book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('dark')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="expanded "><a href="concepts/index.html"><strong aria-hidden="true">1.</strong> Concepts</a></li><li class="expanded "><a href="source/index.html"><strong aria-hidden="true">2.</strong> Source Code Trip</a></li><li class="expanded "><a href="rfcs/index.html"><strong aria-hidden="true">3.</strong> RFCs</a></li><li><ol class="section"><li class="expanded "><a href="rfcs/0001.html"><strong aria-hidden="true">3.1.</strong> 0001</a></li><li class="expanded "><a href="rfcs/0007.html"><strong aria-hidden="true">3.2.</strong> 0007</a></li><li class="expanded "><a href="rfcs/0009.html"><strong aria-hidden="true">3.3.</strong> 0009</a></li><li class="expanded "><a href="rfcs/0010.html"><strong aria-hidden="true">3.4.</strong> 0010</a></li><li class="expanded "><a href="rfcs/0011.html"><strong aria-hidden="true">3.5.</strong> 0011</a></li><li class="expanded "><a href="rfcs/0012.html"><strong aria-hidden="true">3.6.</strong> 0012</a></li><li class="expanded "><a href="rfcs/0013.html"><strong aria-hidden="true">3.7.</strong> 0013</a></li><li class="expanded "><a href="rfcs/0014.html"><strong aria-hidden="true">3.8.</strong> 0014</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">the-darwinia-book</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                            <a href="https://github.com/darwinia-network/the-darwinia-book" title="Git repository" aria-label="Git repository">
                                <i id="git-repository-button" class="fa fa-github"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>This <a href="https://darwinia-network.github.io/the-darwinia-book">book</a> is about <a href="https://github.com/darwinia-network/darwinia">Darwinia</a>, as an open application cross-chain protocol based on <a href="https://github.com/paritytech/substrate">Substrate</a>, <code>Darwinia</code> focuses on the construction of future Internet of Tokens, including the cross-chain of game tokens, NFT, Stablecoins, and Appchain.</p>
<h2><a class="header" href="#background" id="background">Background</a></h2>
<p>The world is being blockchainized and tokenized. Fungible tokens, which has been generally used in the financial industry, together with Non-fungible tokens, which are becoming more and more recognized in the game industry, will greatly enhance the openness and collaboration of finance and game sector.</p>
<p>These tokens are being connected and merged, and the ways of such connection and merger are trends to diversified as well. Such connections might be performed with smart contracts, Dapp, or appchain protocols, that lead to the formation of an open token-network. Darwinia Network powered by polkadot app-parachain technology, via develop infrastructure and core-applications, to support the growth of the token-network. Darwinia focuses its major application in games and de-fi sector.</p>
<h2><a class="header" href="#architecture-design" id="architecture-design">Architecture Design</a></h2>
<p>In the process of using <code>blockchain</code> technology to create new <code>DAPP</code>, we found several problems for the mass promotion and utilization of <code>blockchain</code> technology:</p>
<ol>
<li>The current blockchain infrastructure is not yet able to meet the requirements of user experience.</li>
<li>Traditional game vendors lack blockchain experience.</li>
<li>Blockchain games are split among different public chains.</li>
</ol>
<p>However, <code>blockchain games</code> or Dapps can easily perform <code>cross-chain</code> interactions for game inventories and game operations through the <code>Darwinia Network</code>. For example, <code>Cryptokitties</code> can transform its NFT (Kitties) on the <code>Ethereum</code> into NFT on <code>EOS</code> through the <code>Darwinia chain</code>; players on the <code>Ethereum</code> and players on the <code>EOS</code> can play <code>Evolution Land</code> game simultaneously through the <code>Darwinia Network</code>. <strong>At the same time, thanks to the Polkadot ecosystem, Darwinia Network can link to a wider range of games and players.</strong></p>
<p>The architecture relationship of Darwinia Relay Chain, Darwinia AppChain, Polkadot Relay Chain, etc. is shown as below. </p>
<p><img src="https://github.com/darwinia-network/rfcs/raw/master/RFC/zh_CN/images/0007-darwinia-architecture.jpeg" alt="Darwinia architecture" /></p>
<h2><a class="header" href="#darwinia-relay-chain" id="darwinia-relay-chain">Darwinia Relay Chain</a></h2>
<p><strong>Darwinia Relay Chain is the most important part of the Darwinia Network</strong>, it is also the hub of each App- Parachain, to this end, we divided the operating mode of Darwinia relay chain into <code>Solo mode</code> and <code>Polkadot connection mode</code>.</p>
<h3><a class="header" href="#solo-mode" id="solo-mode">Solo Mode</a></h3>
<p>Darwinia Network can choose to operate as an independent public-chain network and is responsible for its own consensus security, with its core business and application services, including the cross-chain functionality of each application chain, controlled by Darwinia Network itself.</p>
<h3><a class="header" href="#polkadot-connection-mode" id="polkadot-connection-mode">Polkadot Connection Mode</a></h3>
<p>In Polkadot connection mode, in addition to operating as a relay chain for Darwinia Network, it also serves as a Parachain for Polkadot.</p>
<h2><a class="header" href="#economic-model" id="economic-model">Economic Model</a></h2>
<h3><a class="header" href="#ring" id="ring">RING</a></h3>
<p>The native token for the Darwinia Network is <code>RING</code>, <code>RING</code> can be used as gas for transactions. Gas include transaction fees, contract execution fees, network bandwidth charges, storage fees, and more.</p>
<p><img src="https://github.com/darwinia-network/rfcs/raw/master/RFC/zh_CN/images/reward.jpeg" alt="Benefits" /></p>
<h3><a class="header" href="#kton" id="kton">KTON</a></h3>
<p>To encourage users to make long term commitments and pledge, users can choose to <strong>lock <code>RING</code> for 3 - 36 months</strong> in the process of Staking, and the system will offer a <code>KTON</code> token as reward for users participating in Staking. During the committed pledge period, users cannot unlock their RING. (Unless they utilise triple the amount of KTON as penalty).</p>
<h2><a class="header" href="#community-ecosystem" id="community-ecosystem">Community Ecosystem</a></h2>
<h3><a class="header" href="#protocol-researcher" id="protocol-researcher">Protocol Researcher</a></h3>
<p>The protocol and standard research’s work is divided into <strong>two parts</strong>. <strong>The first part</strong> comes from the community. <code>Darwinia Network</code> accepts any <code>RFC</code> submission from the community, including new additions, improvements and modifications. These <code>RFCs</code> will be open to the community for full discussion and research to reach a consensus. <strong>The second part</strong> is from the <code>core research team</code>, which is responsible for organizing <code>RFCs</code>, organizing <code>RFC</code> peer audits and security audits, using <code>Darwinia Network</code> governance models and tools for protocol governance and voting, and forming a final agreement design draft for delivery to the protocol development team.</p>
<h3><a class="header" href="#developer" id="developer">Developer</a></h3>
<p>Develop and improve <code>Darwinia Network</code>, <code>Darwinia AppChain</code> and <code>related services</code>, and develop applications and services using the <code>Darwinia Network</code> and the <code>Darwinia AppChain</code>. Early community open source software development, especially important infrastructure software development (including network protocol design, protocol implementation, node software, wallet, browser, etc.), will be sponsored and supported by the Darwinia Network oundation, currently the main <code>Darwinia Network</code> open source software developer is <a href="https://itering.io">Itering Tech</a>.</p>
<h3><a class="header" href="#dapp-developer" id="dapp-developer">Dapp Developer</a></h3>
<p><code>Dapp developers</code> include developers who develop applications based on the <code>Darwinia Web Smart Contracts module</code>, as well as developers who develop Dapp on the public chain, such as blockchain games or Defi applications on platforms such as <code>Ethereum</code>, <code>TRON</code> or <code>EOS</code>. For the Dapp and game inventories on the public chain, bridge parachain of Darwinia Network can be connected to the Darwinia Network for <code>cross-chain</code> transfer operations.</p>
<h3><a class="header" href="#appchain-developer" id="appchain-developer">AppChain Developer</a></h3>
<p><code>Application chain developers</code> developing with the <code>Darwinia Web Application</code> Suite (Darwinia AppChain).</p>
<h1><a class="header" href="#concepts" id="concepts">Concepts</a></h1>
<h1><a class="header" href="#source-code-trip" id="source-code-trip">Source Code Trip</a></h1>
<h1><a class="header" href="#rfcs" id="rfcs">RFCs</a></h1>
<table><thead><tr><th>rfc</th><th>title</th><th>status</th><th>desc</th></tr></thead><tbody>
<tr><td><a href="rfcs/./0001.html">0001</a></td><td>Darwinia Architecture</td><td></td><td></td></tr>
<tr><td><a href="rfcs/./0007.html">0007</a></td><td>Darwinia Staking Model</td><td></td><td></td></tr>
<tr><td><a href="rfcs/./0009.html">0009</a></td><td>Darwinia liquid kton reward</td><td>Abandoned</td><td>Dispatch Ring awards for Kton</td></tr>
<tr><td><a href="rfcs/./0010.html">0010</a></td><td>Darwinia Cross chain nft bridge protocol</td><td>Draft</td><td>Cross-chain NFT Bridge Protocol</td></tr>
<tr><td><a href="rfcs/./0011.html">0011</a></td><td>Using harberger tax to find price for xclaim vault collaterals</td><td>Abandoned</td><td>XClaim Based NFT Solution Using Harberger Tax</td></tr>
<tr><td><a href="rfcs/./0012.html">0012</a></td><td>Darwinia bridge core interoperation in chainrelay enabled blockchains</td><td>Draft</td><td>Darwinia Bridge Core - Interoperation in ChainRelay Enabled Blockchains</td></tr>
<tr><td><a href="rfcs/./0013.html">0013</a></td><td>Darwinia cross chain nft standards</td><td>Draft</td><td>Darwinia Cross-chain NFT Standards</td></tr>
<tr><td><a href="rfcs/./0014.html">0014</a></td><td>Darwinia token migration by cross chain redeem protocol</td><td>Draft</td><td>Darwinia Token Migration By Cross-chain Redeem Protocol</td></tr>
</tbody></table>
<h1><a class="header" href="#0001" id="0001">0001</a></h1>
<ul>
<li>功能描述: 达尔文网络的开发架构描述</li>
<li>开始时间: 2019-04-28</li>
<li>RFC PR: None</li>
<li>Github Issue: None</li>
</ul>
<h2><a class="header" href="#概要" id="概要">概要</a></h2>
<p>达尔文网络（DARWINIA）基于Substrate开发的跨链应用枢纽和资产互联网络。</p>
<p>达尔文网络是开放的应用跨链协议，主要专注于建设未来资产互联网络，包括游戏资产和非标资产的跨链，稳定币的跨链，应用链跨链等业务。</p>
<p>通过达尔文网络，用户将可以使用达尔文网络来实现资产的跨链转账和流通，开发者可以通过使用达尔文网络便捷的跨链基础服务，实现应用链资产的跨链互联。</p>
<h2><a class="header" href="#动机和目的" id="动机和目的">动机和目的</a></h2>
<p>达尔文网络需要一个很好的跨链技术架构来支撑进化星球的业务体系。</p>
<h2><a class="header" href="#guide-level-explanation" id="guide-level-explanation">Guide-level explanation</a></h2>
<p>关于Polkdot的网络拓扑可以参考其白皮书，其网络拓扑的发展会有点像分形结构，即局部的网络拓扑和整体的网络拓扑会是同构且比较相似。下面的图片列出了达尔文网络可能在网络中的位置。</p>
<p><img src="https://github.com/darwinia-network/rfcs/blob/master/RFC/zh_CN/images/0001-darwinia.png?raw=true" alt="Polkadot and Darwinia networks" /></p>
<h2><a class="header" href="#reference-level-explanation" id="reference-level-explanation">Reference-level explanation</a></h2>
<p>关于Substrate框架的详细介绍，可以参考下面的一些代码库和文档。</p>
<ul>
<li><a href="rfcs/Substrate">https://github.com/paritytech/substrate</a></li>
<li><a href="rfcs/Polkadot%E5%92%8CSubstrate%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%8E%A5%E5%8F%A3%E5%92%8CJS%E5%BA%93">https://polkadot.js.org/</a>.</li>
<li><a href="rfcs/Substrate%E6%96%87%E6%A1%A3%E5%92%8C%E4%B8%8A%E6%89%8B%E8%B5%84%E6%96%99">https://docs.substrate.dev/</a></li>
</ul>
<h2><a class="header" href="#缺点" id="缺点">缺点</a></h2>
<p>比较依赖Substrate的开发设计和进度。</p>
<h2><a class="header" href="#理由" id="理由">理由</a></h2>
<ul>
<li>Substrate是Polkadot底层的框架，符合达尔文网络跨链的理念</li>
<li>最新的技术框架，比较好的底层模块解耦和支持，可以定制SRML</li>
<li>可以很方便的接入Polkadot，站在巨人的肩膀上</li>
</ul>
<h2><a class="header" href="#拓展的模块" id="拓展的模块">拓展的模块</a></h2>
<ul>
<li>RING模块</li>
<li>KTON模块</li>
<li>Staking模块</li>
<li>eth-relay模块</li>
<li>eth-backing模块</li>
</ul>
<h2><a class="header" href="#参考" id="参考">参考</a></h2>
<ul>
<li>[1] https://github.com/cosmos/cosmos/blob/master/WHITEPAPER.md</li>
<li>[2] https://github.com/w3f/polkadot-white-paper/raw/master/PolkaDotPaper.pdf</li>
<li>[3] https://www.parity.io/substrate/</li>
<li>[4] https://imgland.l2me.com/files/evolutionland/whitepaper_en.pdf</li>
<li>[5] https://en.wikipedia.org/wiki/Triffin_dilemma</li>
</ul>
<h1><a class="header" href="#0007" id="0007">0007</a></h1>
<ul>
<li>功能描述: 达尔文通证和Staking模型(Darwinia AppChain)</li>
<li>开始时间: 2019-05-23</li>
<li>RFC PR: None</li>
<li>Github Issue: None</li>
</ul>
<h1><a class="header" href="#概要-1" id="概要-1">概要</a></h1>
<p>这边设计稿介绍达尔文网络的通证和Staking模型。</p>
<h1><a class="header" href="#原生资产" id="原生资产">原生资产</a></h1>
<p>RING是达尔文网络的原生资产，RING可以作为交易的燃料费。燃料费包括交易费用，合约执行费用，网络带宽费用，存储费用等等。</p>
<p>RING在达尔文网路主网上线时的供应量为20亿，之后将会通过出块奖励将新发行的RING分发Staking系统和Treasury。</p>
<p>在达尔文主网上线后，该年的出块奖励每年调整一次，第N年的块奖励为剩余可发行供应量的 <code>1 - (99 /100)^sqrt(N) </code>。</p>
<pre><code>剩余可发行总量 = 硬顶总量 - 当前供应量

下一年的供应量 = 上一年的供应量 + 该年实际出块奖励总和

</code></pre>
<p>RING的硬顶总量为100亿。</p>
<p>根据每年的出块奖励，和出块间隔时间(单位：秒)，可以算出这一年的每个块的出块奖励。</p>
<pre><code>每个块的块奖励 = 该年出块奖励 × 出块间隔时间 ÷ 每年总秒数(即365乘24乘3600)
</code></pre>
<h1><a class="header" href="#收益分配" id="收益分配">收益分配</a></h1>
<p>达尔网络总收入包括出块奖励和达尔文网络交易手续费。达尔文网络交易手续费包括网络手续费，跨链服务质押费用，应用链链的接入费用，以及相关应用比如进化星球自主选择分配给达尔文网络的收入。</p>
<p><img src="https://github.com/darwinia-network/rfcs/raw/master/RFC/zh_CN/images/reward.jpeg" alt="收益分配" /></p>
<pre><code>Staking = 系统收入 × Y
Treasury = 系统收入 × (1 - Y)
</code></pre>
<p>Treasury主要用于支付系统提案预算，可能包括NFT挖矿或App挖矿等系统运营提案，Polkadot槽位竞价激励，或者用于生态开发者支持。</p>
<p>备注: 系统Staking收益是达尔网络总收入的一个百分比Y(Y为系统参数)。
Staking
达尔文网络将会把主要收入作为激励分发给Staking的参与者。Staking的过程也可以理解为POS挖矿过程，挖矿者通过质押资产来获得Staking能量来进行POS挖矿。</p>
<p>一般来说，用户可以通过质押基础资产RING来进行POS挖矿，如果用户开始取回Staking质押的RING，那么挖矿将停止，解除质押的RING将需要14天时间可以完全到账。</p>
<p>Staking按照简单和复杂程度，可以分为基础版和专业版。</p>
<p><img src="https://github.com/darwinia-network/rfcs/raw/master/RFC/zh_CN/images/staking_flow.jpeg" alt="Staking流程" /></p>
<h1><a class="header" href="#氪石kton" id="氪石kton">氪石(KTON)</a></h1>
<p>为了鼓励用户进行长期锁定和承诺投入，用户在Staking RING的过程中，可以承诺锁定RING 3 - 36个月，系统会给参与Staking的用户一个氪石的通证进行奖励，但在承诺锁定期间无法进行解锁RING操作(除非缴纳3倍的氪石罚金)。</p>
<p>因此，用户在使用RING进行Staking过程中，可以选择承诺锁定RING一段时间来获得氪石。氪石的初始供应量为零，但主网上线前进化星球应用已经开始锁定RING获得氪石，因此主网上线时将会存在一定的氪石供应量。最早通过锁定RING获得氪石的设计出现在进化星球古灵阁银行，相关的介绍可以参考古灵阁氪石模型[5]。</p>
<p>氪石可以用于质押获得Staking能量，所以同样也可以参与POS挖矿。用户通过质押氪石进行Staking，如果用户开始取回Staking质押的氪石，那么挖矿将停止，解除质押的氪石将需要14天时间可以完全到账。</p>
<h1><a class="header" href="#staking算力" id="staking算力">Staking算力</a></h1>
<p>某账户的Staking算力代表此账户当前时间对Staking的贡献值大小，Staking算力可以类比为POW中的算力。每个账户的算力值由该账户中质押的RING和KTON资产来决定，一旦解除质押，相应的算力也将消失。</p>
<p>账户的Staking算力比随其质押的资产多少不断变化，不能转移或者转账。Staking参与者可以通过修改投票支持的验证人，在不需要解锁质押的情况下，更改投票支持的验证人。</p>
<p>算力值有可能还将在系统的治理和升级中扮演重要角色。(备注2)</p>
<p>算力值占总算力值的比例称做算力占比。</p>
<pre><code class="language-angular2">算力 = 总算力值 × 算力占比

该账户算力占比 = 算力占比(RING部分) + 算力占比(氪石部分)
</code></pre>
<p>RING和氪石贡献的算力占比计算公式如下：</p>
<pre><code class="language-angular2">算力占比(RING部分) = RING算力贡献比例 × 质押中的RING / RING质押的总数

算力占比(氪石部分) = (1 - RING算力贡献比例) × 质押中的氪石 / 氪石质押总数
</code></pre>
<p>该账户的Staking收益公式如下：</p>
<pre><code class="language-angular2">账户Staking收益 = (达尔网络总收入 × Y) × 账户算力占比
</code></pre>
<p>该账户的投票权重公式如下：</p>
<pre><code class="language-angular2">账户投票权重 = 总投票权重 ×  账户算力占比
</code></pre>
<p>备注1:  RING算力贡献比例默认为0.5。</p>
<p>备注2: 因为氪石可以转售给其他人，所以流动性的氪石可能无法完全代表长期承诺投入，只有承诺锁定和质押的”资产×天数”才能准确代表对达尔文网络的承诺投入。
Slash算法</p>
<p>为了防止验证人进行攻击，或者出块不稳定，当攻击或者错误发生的时候，系统需要对验证人(包括投票人)质押的资产进行惩罚，惩罚的过程和机制就是Slash算法。</p>
<p>因为达尔文网络中实际存在RING和KTON两种质押资产，因此需要对Slash的算法进行一些补充说明。</p>
<p>Staking系统中惩罚相关的参数将以百分比为单位，当Slash发生后，验证人或用户质押的资产将按照该百分比比例进行惩罚，无论其质押的资产是RING还是KTON。</p>
<p>另外，在达尔文网路质押系统中，RING存在四种主要状态，账户余额、Staking中、锁定Staking中、解除质押中。因此存在两种质押状态的RING资产，即Staking中和锁定Staking中，并且锁定Staking状态的RING有可能存在不同的解锁到期时间。因此在Slash发生时，需要确定不同RING质押资产被Slash的先后顺序和优先级。Staking系统将按照解锁到期的时间先后顺序，优先Slash那些较早到期的质押资产，也就是先Slash不在锁定状态的质押资产，然后Slash那些解锁时间先到期的质押资产。</p>
<h1><a class="header" href="#staking模型设计解释" id="staking模型设计解释">Staking模型设计解释</a></h1>
<p>达尔文网络将会把全部收入作为激励分发给Staking的参与者。</p>
<p>达尔文网络的收入来源大体分为两种：</p>
<ul>
<li>出块奖励(BLOCK_REWARD)，每年的块奖励上限随时间会减少，通胀率将会随着时间快速收缩和降低。</li>
<li>达尔文网络交易手续费(NETWORK_FEE)，包括开发者使用达尔文网络的跨链服务，达尔文网络平行链的接入费用，以及相关应用比如进化星球自主选择分配给达尔文网络的收入。</li>
</ul>
<p>因为Polkadot网络采用共享池安全的模型，所以处于Polkadot 连接模式时，平行链的安全性将由由中继链的验证人来保证，达尔文网络在此情况下不需要负责验证，只需要负责Collator即可。</p>
<p>因此，达尔文网络的 Staking 在这两种模式下的安全激励也会有很大不同，具体如下。Solo 模式收入分配</p>
<p>验证人和 KTON 持有者将会按照一个比例来分享进化星球的收入， KTON 持有者可以同时把自己的 KTON 投票给验证人，获取验证人部分的 Staking 激励。(Y为系统参数，将会通过KTON投票的治理机制来设定)</p>
<pre><code class="language-angular2">（锁定 KTON，全部 KTON, Treasury）= 

[ (块奖励上限 ×氪石锁定率 + NETWORK_FEE)×X% ,  (块奖励上限 ×RING锁定率 + NETWORK_FEE)×Y%), (块奖励上限 + NETWORK_FEE) × (100-X-Y)% ]
</code></pre>
<p>Polkadot 连接模式收入分配</p>
<p>当达尔文网络打算连接至Polkadot网络时，根据Polkadot Parachain Auction[4]的模型，达尔文中继链将需要锁定足够多的DOTs来参与Parachain Slots竞价，是否胜出只与锁定的DOTs多少有关，取决于当时的市场情况。为了获得足够的竞争力，达尔文网络将设计一种众筹锁定竞价机制，以激励达尔文社区参与者帮助竞价。
众筹锁定竞价</p>
<p>Polkadot的Parachain Slot拍卖竞价允许任何类型的抽象账户参与竞价，包括普通地址账户，智能合约账户，平行链账户。这种广泛的抽象账户支持为参与竞价者提供了灵活性，可以设计各种去中心化的竞价模型。达尔文网络将为Polka连接模式设计一种通过众筹锁定DOT来参与Parachain Slots竞价的方式，众筹者不需要将DOT所有权进行转移，只需要将DOT锁定并提供锁定凭证，同时开放一定的投票或者竞价权限供达尔文中继链使用。参与竞价锁定的DOTs是安全的，因为整个过程是通过智能合约(或中继链)完成的，没有任何人可以控制这部分锁定的资产。</p>
<p>当达尔文网络切换至Polkadot连接模式时，达尔文网络不再需要自己的验证人，原来用来激励KTON锁定者Staking的部分将会被用来奖励那些帮助达尔文网络进行DOT锁定竞价的参与者，也就是说，达尔文社区的DOT持有者将可以通过提供DOT竞价锁定凭证，获得RING网络收入奖励。</p>
<pre><code class="language-angular2">（达尔文竞价锁定DOT，全部 KTON, Treasury）= 
[ (块奖励上限 + NETWORK_FEE) × X% ,  (块奖励上限 × RING锁定率 + NETWORK_FEE) × Y% , (块奖励上限 + NETWORK_FEE) ×(100-X-Y)%) ]
</code></pre>
<h2><a class="header" href="#其他架构参考" id="其他架构参考">其他架构参考</a></h2>
<ul>
<li><a href="https://blog.cosmos.network/economics-of-proof-of-stake-bridging-the-economic-system-of-old-into-the-new-age-of-blockchains-3f17824e91db">Cosmos Staking</a></li>
<li><a href="https://medium.com/polkadot-network/polkadot-proof-of-concept-4-arrives-with-new-ways-to-stake-3b27037346cc">Polkadot Staking</a></li>
<li><a href="https://wiki.polkadot.network/en/latest/polkadot/learn/auction/">Polkadot Parachain Slot Auction</a></li>
</ul>
<h1><a class="header" href="#参考和实现" id="参考和实现">参考和实现</a></h1>
<h2><a class="header" href="#代码库" id="代码库">代码库</a></h2>
<p>https://github.com/darwinia-network/darwinia/tree/develop/srml/staking</p>
<h2><a class="header" href="#主要特性和创新wip" id="主要特性和创新wip">主要特性和创新[WIP]</a></h2>
<ul>
<li>支持Solo模式和波卡连接模式的无缝切换</li>
<li>二阶Staking模型：锁定的氪石相当于二阶的锁定RING</li>
<li>氪石是根据古灵阁氪石利息算法生成的，鼓励长期锁定和长期投入者</li>
<li>Staking权益和投票权的通证化，Staking后的锁定氪石即为投票权</li>
</ul>
<h1><a class="header" href="#缺点-1" id="缺点-1">缺点</a></h1>
<ul>
<li>设计变更: 应用层面的流动性模型可以采取类似Uniswap模型的方案</li>
</ul>
<h1><a class="header" href="#理由wip" id="理由wip">理由[WIP]</a></h1>
<h1><a class="header" href="#现有技术" id="现有技术">现有技术</a></h1>
<ul>
<li>https://github.com/evolutionlandorg/bank</li>
<li>https://github.com/evolutionlandorg/darwinia-appchain/tree/master/srml/token</li>
</ul>
<h1><a class="header" href="#问题" id="问题">问题</a></h1>
<p>[WIP]</p>
<h1><a class="header" href="#未来的可能性" id="未来的可能性">未来的可能性</a></h1>
<h3><a class="header" href="#kton虚拟银行未来商业拓展计划之贷款业务" id="kton虚拟银行未来商业拓展计划之贷款业务">KTON虚拟银行未来商业拓展计划之贷款业务</a></h3>
<p>当未来RING有足够的流动性，且虚拟银行中有锁定的RING的时候，任何玩家可以通过抵押足够(3倍)的资产(例如ETH)，向虚拟银行贷款，但是需要在贷款时支付氪石贷款利息 D。用户到期后，可以返回借出的RING，换回抵押资产。</p>
<pre><code>D(N, X, S) = R(N, X, S) * (贷款倍数) 暂定贷款倍数为2
</code></pre>
<p>借贷者缴纳的氪石贷款利息将会被虚拟银行销毁。</p>
<p>任何时候如果虚拟银行发现抵押不充足(平仓线，低于1.3倍)时，任何人可以通过平仓动作，支付RING给虚拟银行，换回锁定的抵押物。(这个部分设计可以参考MakerDAO)</p>
<p>氪石将作为RING长期持有者和价值投资者的奖励，在系统重要投票和系统创始道具购买上扮演重要角色，例如某些保留的地块，只能用氪石购买。</p>
<h1><a class="header" href="#参考-1" id="参考-1">参考</a></h1>
<ul>
<li><a href="https://github.com/darwinia-network/rfcs/raw/master/RFC/zh_CN/images/staking_flow.jpeg">1</a> <a href="https://forum.evolution.land/topics/55">进化星球虚拟银行和氪石</a></li>
<li>[2] <a href="https://mp.weixin.qq.com/s/-Va8Q8I6zTtpNdJImkslrg">PoW的好处</a></li>
<li>[3] <a href="https://baike.baidu.com/item/%E5%B9%B4%E5%8C%96%E5%88%A9%E7%8E%87/5834305">年化利率</a></li>
</ul>
<h1><a class="header" href="#0009" id="0009">0009</a></h1>
<ul>
<li>功能描述: 给流动KTON分发RING收益</li>
<li>开始时间: 2019-05-13</li>
<li>RFC PR: None</li>
<li>Github Issue: None</li>
</ul>
<h1><a class="header" href="#概要-2" id="概要-2">概要</a></h1>
<p>在达尔文网络Solo模式设计中，需要给全部KTON进行RING收益的分发，这意味着收益分发前后KTON都是可以转账和流动的，即需要可以支持给流动KTON进行RING收益的分发。</p>
<p>由于分发收益时，需要明确确定收益所有权的界限，因此在分发收益时，一般都需要锁定权益通证，以方便清算。但是在达尔文网络Solo模式中，需要支持KTON可以流动，因此RING收益如果想要做到实时，需要将颗粒度放小，在任何KTON发生转账前后进行清算。</p>
<p>以太坊中的ERC20的转账，只需要记录balance的变化即可，但在KTON中，需要记录其当前收益的情况，以方便清算。可以理解为:</p>
<h2><a class="header" href="#kton转账模型" id="kton转账模型">KTON转账模型</a></h2>
<p>通常原生代币的转账可以理解为</p>
<pre><code class="language-angular2">Normal_Transfer = Sender_Output + Receiver_Input
</code></pre>
<p>KTON的转账可以理解为</p>
<pre><code class="language-angular2">KTON_Transfer = Reward_Settlement(Sender_KTON_Output) + Sender_KTON_Output + Receiver_KTON_Input + Reward_Settlement(Receiver_KTON_Input)
</code></pre>
<h3><a class="header" href="#参考以太坊p3d的reward_settlement做法" id="参考以太坊p3d的reward_settlement做法">参考以太坊P3D的Reward_Settlement做法</a></h3>
<p>在P3D Token中，没有Transfer方法，只有Withdraw和Deposit方法，但实际上Transfer方法可以通过组合的方式得出，也就是说</p>
<p>Transfer(sender, to) = sender.Withdraw + to.Deposit</p>
<p>因为P3D中也存在收益分配的做法，因此Withdraw和Deposit中也需要进行Reward_Settlement操作.</p>
<p>即</p>
<pre><code class="language-angular2">sender.Withdraw = sender.Reward_Settlement(Output) + sender.normal_withdraw(Output)
</code></pre>
<pre><code class="language-angular2">to.Deposit = to.normal_deposit(Input) + to.Reward_Settlement(Input)
</code></pre>
<p>在KTON没有发生转账的情况下，也有可能会发生Reward_Settlement:</p>
<pre><code>- 有收益进账，需要进行分配
    对于这种情况，如果每一次收益分配时，都对每个KTON持有者的收益余额进行计算，会消耗大量的计算资源，因此不切实际。改进的办法是，KTON持有者的收益都放入一个池子，在需要清算时再针对单个KTON持有者进行计算。
    因此，收益进账后，只有收益池的总额发生了变化。
- KTON持有者Claim收益
    但某一个KTON持有者希望Claim收益时，会根据收益池RING总量，该持有者的KTON数量，KTON总量，按比例计算出可以Claim的收益，并将该次收益提现记录进该账户已提现的总量。
    
    该账户可提现数量 = 该账户可提现数量(已清算 + 未清算) - 该账户已提现数量
</code></pre>
<h1><a class="header" href="#动机和目的-1" id="动机和目的-1">动机和目的</a></h1>
<ul>
<li>提供一个可以给流动性原生通证清算收益的技术方案</li>
</ul>
<h1><a class="header" href="#参考和实现-1" id="参考和实现-1">参考和实现</a></h1>
<h2><a class="header" href="#代码库-1" id="代码库-1">代码库</a></h2>
<p>https://github.com/darwinia-network/darwinia/tree/master/srml/kton</p>
<h2><a class="header" href="#主要特性wip" id="主要特性wip">主要特性[WIP]</a></h2>
<ul>
<li>支持转账</li>
<li>支持Staking收益分配</li>
<li>支持领取收益</li>
<li>收益分配可以实时进行</li>
</ul>
<h1><a class="header" href="#缺点-2" id="缺点-2">缺点</a></h1>
<ul>
<li>转账时需要多出一定的链上收益清算计算量</li>
<li>如果KTON持有者的账户是合约账户，那么目前的RING收益只能该合约账户去领取，但是合约账户是否支持是个问题。</li>
<li>本解决方案范围不包括在其他公链(例如以太坊或者波场)上的KTON收益分配，对于其他网络上的KTON，应该会统一在达尔文中继链上创建一个账户，用于领取收益，具体的收益则在对应公链上发生，例如目前进化星球基于状态通道的收益分配方式并不会发生变化，好处是相应的KTON也可以得到收益。</li>
</ul>
<h1><a class="header" href="#理由-1" id="理由-1">理由</a></h1>
<p>具体Staking的设计参考RFC-0007。具体的技术方案则参考了P3D的实现。P3D没有支持转账方法，有其业务层面的考虑，也有可能因为转账操作的燃料费消耗考虑。
但对于KTON这样的原生通证，可以再SRML层面实现。</p>
<h1><a class="header" href="#现有技术-1" id="现有技术-1">现有技术</a></h1>
<h1><a class="header" href="#以太坊上一些常见的收益分配方案可以作为参考" id="以太坊上一些常见的收益分配方案可以作为参考">以太坊上一些常见的收益分配方案可以作为参考</a></h1>
<h2><a class="header" href="#erc-20回购销毁分红法" id="erc-20回购销毁分红法">ERC-20回购销毁分红法</a></h2>
<p>对通证进行销毁，其实是一种变相等价的分红方法，其他通证持有人手上的通证数量没有变化，但是比例上升，且供应量减少但对应系统的价值没有变化，本质上其实也是一种分红，具体案例参考BNB回购销毁分红。</p>
<p>该方法的缺点在于，需要分红通证和权益通证之间有较好的流通性市场，才能通过回购的方式将分红通证兑换成权益通证，进而将权益通证销毁进行分红，否则不适合使用此方法。</p>
<p>另外，虽然数学上回购销毁几乎等同于分红，但是从市场感知上不明显，从普通用户视角来看，不如看到账面上余额数字的增加来得容易感知。所以，实际效果上回购销毁不如直接分发。</p>
<h2><a class="header" href="#erc-20冻结转账p3d分红方法" id="erc-20冻结转账p3d分红方法">ERC-20冻结转账(P3D)分红方法</a></h2>
<p>将主要以P3D为例解释这种通过合约进行分红的方法。</p>
<p>P3D严格意义上不同于ERC20通证，因为不支持通证转账功能，只存在购入和卖出两种方式变更通证持有者的余额。P3D因为这种简化反而对分红方法带来了简化，也就是只需要在通证持有者余额变化时更新持有者的分红数量，实现精确的合约分红。</p>
<p>具体实现是，维护以下账本，以权益通证P3D和分红币ETH为例：</p>
<p>Total_ETH_Dividends_Balance,  所有历史分红的总和，只会增加不会减少。每次分红的时候会增加。
My_ETH_Dividends_Balance_Claimed[address], 某P3D持有者放在系统保险箱里的ETH分红余额，刚开始为0，但是每次持有者P3D余额变化（购入，卖出）的时候ETH分红余额会更新并增加，持有者可以从中领取分红到自己的钱包，并相应减少。</p>
<p>Last_Claim_Total_ETH_Dividends_Balance[address], 某P3D持有者上一次Claim时，Total_ETH_Dividends_Balance的值，每次持有者余额变化（购入，卖出）的时候会更新。
每次持有者余额变化（购入，卖出）的时候，操作之前的P3D余额为balance_before, P3D总额为balance_total_before，操作之后的P3D余额为balance_after, P3D总额为balance_total_after，持有者的地址为address。则首先会进行第2、3账本的更新。</p>
<pre><code>My_ETH_Dividends_Balance_Claimed[address] += {Total_ETH_Dividends_Balance - Last_Claim_Total_ETH_Dividends_Balance[address]} * [balance_before/balance_total_before]
Last_Claim_Total_ETH_Dividends_Balance[address] = Total_ETH_Dividends_Balance
</code></pre>
<p>进行其他P3D余额的变化</p>
<p>优点，去中心化方式，合约分账分红。缺点，可能需要锁定转账功能。</p>
<p>ERC20中持有者余额变化频繁，可以通过转账，发行，销毁等方式进行，如果每次转账都需要触发分红合约，会增加不必要燃料费，并增加合约复杂度，并且大多数ERC20通证并不支持在转账交易中做额外的事情。(部分ERC223可能支持，KTON的具体实现也比较复杂，友好支持程度偏悲观)。除非要求ERC20代币锁定之后，可以使用这个方法。</p>
<p>https://etherscan.io/address/0xb3775fb83f7d12a36e0475abdd1fca35c091efbe#code</p>
<h1><a class="header" href="#问题-1" id="问题-1">问题</a></h1>
<p>[WIP]</p>
<h1><a class="header" href="#未来的可能性-1" id="未来的可能性-1">未来的可能性</a></h1>
<ul>
<li>做成一个通用的SRML</li>
</ul>
<h1><a class="header" href="#参考-2" id="参考-2">参考</a></h1>
<ul>
<li>[1] <a href="https://github.com/darwinia-network/rfcs/issues/6">RFC Issue</a></li>
<li>[2] <a href="https://etherscan.io/address/0xb3775fb83f7d12a36e0475abdd1fca35c091efbe#code">P3D代码实现</a></li>
</ul>
<h1><a class="header" href="#0010" id="0010">0010</a></h1>
<h2><a class="header" href="#i-概述" id="i-概述">I. 概述</a></h2>
<p>基于XClaim的框架给通证跨链提供了一个思路，但是对于NFT仍有很多问题，其中主要包括Backing Blockchain上 Vault抵押物设计的问题。通过在Backing Blockchain上引入chain-Relay合约可以有效的解决这个问题，本文将基于这个改进的跨链转接桥方案，设计跨链NFT的方案和标准。</p>
<p><strong>关键词</strong>：Blockchain, NFT, cross chain, multi-chain</p>
<h2><a class="header" href="#ii-背景" id="ii-背景">II. 背景</a></h2>
<h3><a class="header" href="#a-研究历史" id="a-研究历史">A. 研究历史</a></h3>
<p>比特币[1]的出现，允许每个人只要拥有私钥，就可以不依赖任何信任地操作自己的资产。整个比特币系统，由一系列记录着自己前序区块hash的区块构成，共同维护着同一份去中心化的全球“账本”。</p>
<p>比特币的出现之后，紧接着的就是区块链的飞速发展，出现了支持智能合约的公链——以太坊[2]，PoS的公链——EOS[3]等。这些公链的爆发，带来了整个token交易市场的繁荣。</p>
<p>主流的token交易/交换方式仍然是中心化交易所，用户的token由中心化交易所代为管理。信任和维护成本很高，并且还需要面临源源不断的黑客攻击的威胁。</p>
<p>为了克服中心化交易所的弊端，去中心化交易所 (DEX) 开始涌现。绝大部分去中心化交易所只支持在一条链上进行链内的token交易/转换，比如以太坊上的ERC20[4], ERC721 token[5]. 这一定程度上实现了去中心化，降低了信任成本（从相信机构变成了相信代码），但是使用场景十分有限，并且还要受限于公链的tps和交易费用。</p>
<p>当然也有一部分的去中心化交易所实现了ACCS，允许token跨链交换。它们使用了hashed timelock contracts (HTLCs)[6].  HTLCs的优点同它的缺点一样，都很明显。HTLCs可以在不需要信任的情况下实现跨链token的原子交换，这既实现了去中心化，又拓展了单条链上的DEX的功能。它的缺点就是成本太高，并且限制条件很多：(i) 所有参与方都必须保持全过程在线  (ii) 对粉尘交易失效  (iii) 通常锁定时间较长。这样的token跨链交换既昂贵又低效。在实际使用中，HTLCs的使用范例也非常少。</p>
<p>为了实现去信任的、低成本的、高效率的token跨链操作，XClaim团队提出了cross claim方案，基于CBA。并且在XClaim的论文中详述了XClaim是如何完成以下四种操作的：Issue, Transfer, Swap and Redeem.</p>
<p>XClaim系统中保证经济安全的角色被称为 $vault$,  如果任何人想要把chain $B$ 上的原生token $b$ 跨到 chain $I$ 变成 $i(b)$ ，那么就需要 $vault$ 在chain $I$ 上超额抵押 $i$ 。 在赎回操作中，如果 $vault$ 存在恶意行为，则罚掉 $vault$ 抵押的 $i$ ，用于赎回操作发起者。其他细节详见XClaim的论文[7]。</p>
<p>至此，对于流动性较好的Fungible token的跨链，已经得到一个可靠的、可实现的方案。</p>
<h3><a class="header" href="#b-xclaim框架存在的问题" id="b-xclaim框架存在的问题">B. XClaim框架存在的问题</a></h3>
<p>XClaim方案中有着一个基本假设，即跨链锁定的chain $B$ 的原生token $b$ 的总价值， 与在 $I$ 上发行出的 $i(b)$ 的总价值相等，在XClaim中被称为<em>symmetric</em>, 即 $|b| = |i(b)|$。这样的假设是的XClaim在NFT的跨链中存在着天然的困境：</p>
<ul>
<li>NFT的不可替代性。正因为NFT具有可识别性、不可替代性等特点，使得 $vault$ 在 chain $I$ 上抵押chain $B$ 上的 NFT $nft_b$ 成了一件不可能的事情。</li>
<li>NFT的价值难以评估。在XClaim中，判断 $vault$ 的抵押是否足额/超额，是通过Oracle $O$ 实现的。这也存在一个潜在的假设：token $b$ 和 token $i$ 可以被正确地评估价值。基于目前繁荣的中心化和去中心化交易所，在提供了良好的流动性的情况下，是可以基本满足该潜在假设的。但是NFT交易所市场尚未成熟，即使中心化交易所也无法比较真实地反应市场对NFT的价格判断。NFT如何定价本身就是一个难题。</li>
<li>NFT定价不具有连续性和可预测性。即使某个NFT在市场上有了一次成交记录，即有了一个价格，因为NFT被售出的频次远低于FT，即使在市场流动性非常好的情况下，该NFT下一次的成交价格既不连续，也不可预测。</li>
</ul>
<h3><a class="header" href="#c-解决方案和思路" id="c-解决方案和思路">C. 解决方案和思路</a></h3>
<p>解决以上问题的NFT跨链方案有两种思路，一种是基于XClaim框架并保留桥质押机制的的NFT扩展，通过引入哈伯格机制来解决NFT定价问题，详细的解决方案见<a href="rfcs/./0011-using-harberger-tax-to-find-price-for-xclaim-vault-collaterals.html">RFC-0011: Using Harberger Tax to find price for XClaim Vault Collaterals</a>. 但这个方案仍然无法很好的解决由于NFT价格变化太大，导致的质押物不足问题。</p>
<p>另一个思路是通过在Backing Blockchain引入chainRelay的方案，对背书的资产做更多的保护，使得不再需要质押机制，简称为<a href="rfcs/./0012-darwinia-bridge-core-interoperation-in-chainrelay-enabled-blockchains.html">RFC-0012: Darwinia Bridge Core: Interoperation in ChainRelay Enabled Blockchains</a>，详细的介绍将不在本文进行详细介绍，本文将着重基于这个改进的跨链转接桥方案，设计一个跨链的NFT标准，并且在多链互跨的情况下，提出了更低成本、功能具备扩展性的跨链协议。</p>
<p>其中，在<a href="rfcs/./0012-darwinia-bridge-core-interoperation-in-chainrelay-enabled-blockchains.html">RFC-0012</a> V.A中，我们引入了Darwinia Bridge Core的模型，用来优化区块链网络拓扑中的chainRelay数量。本文将基于Darwinia Bridge Hub，并针对NFT特定领域的问题，进行细化设计。</p>
<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7fe8rjjzvj30kb0bfgmc.jpg" alt="chain-relay-framework" style="zoom:80%;" />
<h2><a class="header" href="#iii-nft-in-darwinia-bridge-core" id="iii-nft-in-darwinia-bridge-core">III. NFT in Darwinia Bridge Core</a></h2>
<p>NFT跨链操作的难点在于，不同的公链有着自己的NFT标准，甚至不同公链上的NFT的token id连长度都是不相等的，NFT在跨到不同公链时，必然会经历token id的转换。如何在跨链的过程中不丢失NFT的可识别性，是一个值得研究的命题。</p>
<p>在设计Bridge Core内的NFT流转逻辑时，我们想解决以下三个问题：</p>
<ul>
<li>保留NFT的跨链流转路径/历史，不损失NFT的可识别性；</li>
<li>计算和验证解耦，拥有更高的处理速度；</li>
<li>实现额外功能，例如NFT在跨链的同时完成分解、合并等操作；</li>
</ul>
<p>为此，我们选择为每个经过Bridge Core跨链的NFT引入一些中间解析状态，称为UNFO (Unspent NFT Ouput)，这些UNFO状态将维护一个Bridge Core上全局的ID，并借由跨链流通证明记录全局ID和NFT外部本地ID的映射关系。UNFO并不一定具体负责该NFT在Bridge Core范围内的所有权管理(Ownership Management)，但也可以借由一个$lock_script$进行扩展，例如通过将$lock_script$指向Bridge Core内部的一个所有权管理合约。</p>
<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7fe8qjwd9j30fe0gh3zg.jpg" alt="0010-framework-of-bridge-core" style="zoom:50%;" />
<h3><a class="header" href="#a-组件定义" id="a-组件定义">A. 组件定义</a></h3>
<ul>
<li><em>Issuing Smart Contract</em>,  $iSC_N$:  表示在 chain <em>N</em> 上的资产发行合约；</li>
<li><em>Backing Smart Contract</em>,  $bSC_N$ : 表示在 chain $N$ 上的资产锁定合约；</li>
<li><em>Verifying Smart Contract</em>,  $vSC_N$ : 表示在Bridge Core上负责验证 chain <em>N</em> 上交易的资产发行合约/模块；</li>
<li><em>Global identifier</em> ,  $GID$ , The global idendifier for the NFT in Darwinia Bridge Core</li>
<li><em>Unspent Non-Fungible Output</em> ,  $UNFO$, Intermediate Resolution State for the NFT in Darwinia Bridge Core, aka. unspent NFT output. 该想法源于UTXO，当一个UNFO被销毁时，意味着同时会产生一个新的UNFO.</li>
<li><em>External Backing NFT</em>,  $nft_B^{x,n}$,  表示在chain $B$ 上，在合约 $x$ 中标识为 $n$ 的NFT</li>
<li><em>Bridge Core Mirror for Backing NFT</em>, $nft_{BC(unfo_{gid})}^{B,x,n}$,  或简称$nft_{BC}^{B, n}$ ，跨链到Bridge Core中的中间状态的NFT, 并且和 chain $B$ 上的 $nft_B^{x,n}$ 互为镜像，表示在对应 chain $B$ 中有一个即将被发行/已锁定的 NFT.  $unfo_{gid}$ 表示该NFT在 Bridge Core 内的中间态UNFO.</li>
<li><em>External Issueing NFT</em>,  $nft_I^{x',n'}$,  表示跨链后在chain $I$ 上新增发的、在合约 $x'$ 中标识为 $n'$ 的NFT</li>
<li><em>Bridge Core Mirror for Issuing NFT</em>,$nft_{BC(unfo_{gid})}^{I,x',n'}$, 或简称 $nft_{BC}^{I, n'}$ ，跨链到Bridge Core中的中间状态的NFT, 并且和 chain $I$ 上的 $nft_I^{x',n'}$ 互为镜像，表示在对应 chain $I$ 中有一个即将被发行/已锁定的 NFT.  $unfo_{gid}$ 表示该NFT在 Bridge Core 内的中间态UNFO.</li>
<li><em>Locking Transaction</em> ,  $T_{B}^{lock}$,  在 chain <em>B</em> 上把 NFT 锁定在 $bSC_B$ 中的交易</li>
<li><em>Redeem Transaction</em> ,  $T_I^{redeem}$， 在chain <em>I</em> 上把 NFT 锁定在 $bSC_I$ 中的交易</li>
<li><em>Extrinsic Issue</em>,  $EX_{issue}$ , Bridge Core上的 issue 的交易 </li>
<li><em>Extrinsic redeem</em>,  $EX_{redeem}$ , Bridge Core上的 redeem 的交易 </li>
</ul>
<p>参与方：</p>
<ul>
<li><em>validator</em>,  维护 Bridge Core 的参与方；</li>
</ul>
<h3><a class="header" href="#b-unfo-实现和作用" id="b-unfo-实现和作用">B. UNFO 实现和作用</a></h3>
<h4><a class="header" href="#bi-unfo的数据结构" id="bi-unfo的数据结构">B.I UNFO的数据结构</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct UNFO {
  pub local_id, // chain_id + smart_cotnract_id + token_id
  pub global_id,
  pub phase, // current phase
  pub lock_script, // e.g. ownership or state management
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong>local_id</strong>：表示该UNFO对应着某个外部区块链 <em>chain_id</em> 上某个 <em>smart_contract_id</em> 里的 <em>token_id</em></li>
<li><strong>global_id</strong>：表示该UNFO在Bridge Core和所有被夸的区块链范围内的全局唯一标识</li>
<li><strong>phase</strong>：表示该UNFO在跨链过程中所处的阶段。比如：
<ul>
<li>1: 该UNFO对应区块链 <em>chain_id</em> 上的NFT被锁定/销毁；跨链过程处于中间状态；</li>
<li>2: 该UNFO对应区块链 <em>chain_id</em> 上的NFT待发行/已发行；跨链过程即将完成/已完成</li>
</ul>
</li>
<li><strong>lock_script</strong>：用于更加复杂逻辑、细粒度的控制脚本，保持UNFO的可扩展性。lock_script表达的是这个NFT的所有者是谁，当该NFT在Bridge Core之内流转时，该lock_script指向的可能是某个ownership contract，当NFT被锁定在backing contract里面时，lock_script指向的可能是backing contract的redeem合约</li>
</ul>
<h4><a class="header" href="#bii-unfo的转换" id="bii-unfo的转换">B.II. UNFO的转换</a></h4>
<p>我们选择用UNFO模型作为存储/状态 的流转单元，UNFO模型是一种类似UTXO模型的设计思路。</p>
<p>当一个UNFO的销毁，意味着另一个UNFO的创建，如果我们追溯UNFO的销毁创造历史，就可以回溯某个NFT的全部跨链历史，这一定程度上帮助实现了NFT的可识别性；</p>
<p>每个UNFO只能被销毁一次，这使得计算前不一定要先验证，从而提高了处理速度；</p>
<p>正如比特币的UTXO一样，Input和Output都可以有多个，这样的特点使得NFT在跨链的过程中，可以同时完成一些扩展功能，例如NFT的拆分和合并。</p>
<p>一直一来，NFT都比FT有用更多的操作种类，例如在游戏中，作为道具的NFT要求可拆解、可合成、可升级等，为此扩展出了很多NFT标准，例如ERC721, ERC1155, ERC721X等。标准越多，越难被广泛使用。</p>
<p>如果其中的一些通用需求可以在跨链同时实现，可以有效地减少标准的数量和冗余度，一定程度上更有利于实现一个统一的标准。</p>
<p>当一个UNFO产生时，一定要满足：</p>
<ul>
<li>提供 <em>backing blockchain</em> 的 对应NFT 的锁定记录；</li>
<li>另一个UNFO被销毁
<ul>
<li>条件：销毁和产生的UNFO的GID必须相同</li>
</ul>
</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7fe8skd28j30hj06z0sz.jpg" alt="0010-UNFO-transform" style="zoom:50%;" />
<h4><a class="header" href="#biii-基于unfo的nft映射和id一致性" id="biii-基于unfo的nft映射和id一致性">B.III. 基于UNFO的NFT映射和ID一致性</a></h4>
<p>Fungible Token在跨链时只要保证CBA和原生资产价值对称、资产安全即可，但是NFT对可识别性有更高的要求，因此需要再跨链时更好的维护NFT CBA和原生资产的一一映射，并保持ID的一致性，包括GID和External Locol ID。</p>
<table><thead><tr><th>UNFO</th><th>GID</th><th>External Chain ID</th><th>External Contact Address</th><th>External Token ID</th><th>Lock_Script</th><th>Active Status</th></tr></thead><tbody>
<tr><td>1</td><td>GID0001</td><td>Ethereum</td><td>A_ERC721</td><td>12</td><td>script_issuing_burn_or_relay</td><td>False</td></tr>
<tr><td>2</td><td>GID0001</td><td>Tron</td><td>B_TRC721</td><td>?</td><td>script_backing_redeem</td><td>True</td></tr>
<tr><td>3</td><td>GID0002</td><td>EOS</td><td>C_dGoods</td><td>2.5.4</td><td>script_issuing_burn_or_relay</td><td>False</td></tr>
</tbody></table>
<center>基于UNFO的映射表示例</center>
假如我们用nft(Exterenal_Chain_ID, External_Contract_Address, External_Token_ID)标识一个外部公链上的NFT。在没有NFT的跨链映射表的情况下：
<blockquote>
<p>nft(A, X, 1) 表示在A链上、合约X中标识为1的NFT。</p>
</blockquote>
<p>在没有NFT的跨链映射表的情况下，</p>
<blockquote>
<p>Alice在跨链桥M(A-&gt;B)中，将nft(A, X, 1) 变为 nft(B, Y, 2) ；又通过跨链桥N(B-&gt;C)，将nft(B, Y, 2) 变为 nft(C, Z, 3)。之后，当Alice想继续使用跨链桥M将C链上的nft 跨链去 A链的话，因为没有跨链映射表查询该NFT在A中的ID信息，跨链桥M会将 nft(C, Z, 3) 识别为新的NFT CBA，这样很可能在跨回A链时，将不再是nft(A, X, 1)，而是nft(A, X, 5). NFT就丢失了自己的可识别性和ID一致性，会给协议和赎回过程带来额外的复杂性和混乱。</p>
</blockquote>
<p>为了尽可能减少丢失NFT可识别性对用户造成的潜在资产损失，如果NFT在Bridge Core连接的网络之内跨链，则用户可以获取到Bridge Core上某个NFT当前的基于UNFO的NFT映射表，协议将可以约束用户跨链回A链的NFT需要遵循ID一致性和可识别性。这样，至少在Darwinia Bridge Core系统内，NFT可保证可识别性不被破坏。</p>
<p>为了保持良好的ID一致性，在NFT通过Bridge Core跨链流转的生命周期内，希望保持External Chain ID和 (External Contact Address, External Token ID) 的映射关系保持不变，此时可以通过基于UNFO的解析服务，至UNFO映射表里面查询相应的External Token ID，以保持一致性。在RFC-0013章节III.D中，我们还将详细介绍NFT解析模块。</p>
<h3><a class="header" href="#c-初步实现方案" id="c-初步实现方案">C. 初步实现方案</a></h3>
<p>场景同章节II中的描述。依然需要实现三种 protocol：<em>Issue, Transfer, Redeem</em>. 同样为了简化模型，这里将不会讨论手续费相关细节。</p>
<h4><a class="header" href="#protocol-issue" id="protocol-issue">Protocol: Issue</a></h4>
<p>(i) <em><strong>锁定</strong></em>。<em>requester</em> 将 chain $B$上的NFT资产 $nft_B^{n,x}$ 锁定在 $bSC_B$ 中，同时声明目的地公链 chain <em>I</em> 以及自己在chain $I$ 上的地址；这一步将产生交易$T_B^{lock}$</p>
<p>(ii) <em><strong>Bridge Core上发行</strong></em>。 <em>requester</em>  将锁定交易 $T_B^{lock}$ 提交至 Bridge Core, 对应的chain relay验证通过后，即 触发 $vSC_B$ , 在 $vSC_B$ 中：</p>
<ul>
<li>产生新的$GID$ 和 $nft_{BC}^{B,n}$ , 记录 $GID$ 和 $nft_{BC}^{B,n}$ 二者之间的关系，</li>
<li>并触发$vSC_I$ </li>
</ul>
<p>在 $vSC_I$ 中：</p>
<ul>
<li>销毁  $nft_{BC}^{B,n}$，发行 $nft_{BC}^{I,?}$， $issue_{ex}(\ GID,\ address_on_I) \rightarrow EX_{issue}$</li>
</ul>
<p>(iii) <em><strong>发行</strong></em>。<em>requester</em> 将 $EX_{issue}$ 提交至 chain $I$ , 经过chain $I$ 上的chain relay 验证通过后，即会在$iSC_I$ 中增发新的NFT: $nft_I^{x', n'}$， 并记录 $GID$ 和 $nft_I^{x', n'}$的关系， 且将所有权交给 <em>requester</em> 在chain <em>I</em> 上的地址</p>
<p>注: 对于外部区块链上的$iSC$来说，在发行时，也需要在外部区块链上，将全局ID和本地ID的映射记录下来，因为后面redeem的时候，需要使用这个映射关系来完成redeem.</p>
<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7sznhszi8j30pz0elabd.jpg" alt="chain-relay-framework-1" style="zoom:50%;" />
<h4><a class="header" href="#protocol-transfer" id="protocol-transfer">Protocol: Transfer</a></h4>
<p>(i) <em><strong>转移</strong></em>。<em>sender</em> 在 $I$ 上把 $nft_I^{x',n'}$ 在  $iSC_I$ 中，把所有权转移给 <em>receiver</em>，参考ERC721.</p>
<p>(ii) <em><strong>见证</strong></em>。当 $nft_I^{x',n'}$ 在  $iSC_I$ 中的所有权发生了转移时，$iSC_I$ 和 $bSC_I$ 都应当觉察。此时，当 <em>sender</em> 再想把 $nft_I^{x',n'}$ 赎回时需要先将其锁定在 $bSC_I$ 中，此时 $bSC_I$ 将不会允许该操作成功。</p>
<h4><a class="header" href="#protocol-redeem" id="protocol-redeem">Protocol: Redeem</a></h4>
<p>(i) <em><strong>锁定</strong></em>。 <em>redeemer</em> 将 chain $I$ 上的NFT资产 $nft_I^{x', n'}$ 锁定在 $bSC_I$ 后 (如果有对应的GID，锁定时需声明 $GID$)，同时声明目的地公链chain $B$ 以及自己在 chain $B$ 上的地址；$bSC_I$ 会原子地 在 $iSC_I$ 中确认 $GUID$ 的正确性。这一步将产生交易$T_I^{redeem}$。$lock_I(nft_id_on_I,\ GID,\ address_on_B) \rightarrow T_I^{redeem}$ </p>
<p>(ii) <em><strong>Bridge Core上解锁</strong></em>。 <em>redeemer</em> 将 $T_I^{redeem}$ 提交至 $vSC_I$ 并在chain relay中验证通过后，会在 $vSC_I$ 中：</p>
<ul>
<li>记录 $GID$ 和 $nft_I^{x', n'}$ 的对应关系，</li>
<li>判断目的地公链并触发相应的 $vSC_B$ ,</li>
</ul>
<p>在 $vSC_B$ 中, </p>
<ul>
<li>通过 $GID$检索，销毁 $nft_{BC}^{I,n'}$ ，产生 $nft_{BC}^{B, n}$ ，$ redeem_ex(\ GID,\ nft_id_on_B,\ address_on_I) \rightarrow EX_{issue}$</li>
</ul>
<p>以上过程均在一次Extrinsic内触发，将会产生一笔Extrinsic id，记录为 $EX_{redeem}$</p>
<p>(iii) <em><strong>解锁</strong></em>。 <em>redeemer</em> 将 $EX_{redeem}$ 提交给 chain $B$ ， 经过$iSC_B$ 验证通过后，在 $iSC_B$ 中会记录 $GUID$ 和 $nft_B^{x,n}$ 的对应关系， 同时会原子地触发 $bSC_B$ 中的方法，将 $nft_B^{x,n}$ 还给指定的地址。 </p>
<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7szni9t0lj30r70elgn2.jpg" alt="chain-relay-framework-2" style="zoom:50%;" />
<h3><a class="header" href="#d-algorithms" id="d-algorithms">D. Algorithms</a></h3>
<h5><a class="header" href="#protocol-issue-1" id="protocol-issue-1">Protocol: Issue</a></h5>
<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7sznio88rj30uc0j0aca.jpg" alt="image-20191010113808729" style="zoom:50%;" />
<p>解释：</p>
<h6><a class="header" href="#requester-相关的操作" id="requester-相关的操作"><em>requester</em> 相关的操作：</a></h6>
<ul>
<li>
<p><strong>lockB</strong>($nft_B^{x,n}$, cond):   发生在chain $B$ 内。将$nft_B^{x,n}$ 锁定在 $bSC_B$ 中，并声明 <em>requester</em> 在 chain $I$ 上的地址，这个操作对应交易 $T_B^{lock}$</p>
</li>
<li>
<p><strong>verifyBOp</strong>(lockB, $T_B^{lock}$, $\Delta_{lock}$) $\rightarrow T$ :    发生在Bridge Core内。<em>requester</em>将 $T_B^{lock}$ 提交至 Bridge Core中的 $vSC_B$ 进行验证，如果 $T_B^{lock}$ 真实地在 chain $B$ 上发生过并且满足最小需要延时 $\Delta_{lock}$，即返回结果T(True)，否则返回F(False).</p>
<p>如果结果为T，则在 $vSC_B$ 中自动触发 newGid($nft_B^{x,n}$)，会产生新的GID，以及 $nft_B^{x,n}$ 在 Bridge Core内的镜像 $nft_{BC}^{B,n}$ ，并建立GID和 $nft_{BC}^{B,n}$ 的对应关系</p>
</li>
<li>
<p><strong>verifyBCOp</strong>(trigger, $EX_{issue}$, $\Delta_{trigger}$) $\rightarrow T$ :  发生在 chain $I$ 内。<em>requester</em> 将 $EX_{issue}$ 提交至chain $I$ 的 $iSC_I$ 内，如果$iSC_I$ 验证 $EX_{issue}$ 的真实性即返回T，否则返回F。验证通过后，即通过调用issue方法，发行 $nft_I^{x',n'}$ 到 <em>requester</em> 在 chain $I$ 的地址上。</p>
</li>
</ul>
<h6><a class="header" href="#validator-相关操作" id="validator-相关操作"><em>validator</em> 相关操作：</a></h6>
<ul>
<li><strong>issueTransform</strong>($vSC_I,\ pk_I^{requester},\ GID$ ): <em>validator</em> 会自动触发 $vSC_I$ 中的方法， 将 $nft_{BC}^{B,n}$ 销毁并产生 $nft_{BC}^{I,?}$ 表示在chain $I$ 上即将新增发的nft的镜像（这里之所以用$?$ 因为此时chain $I$ 上的nft还未被增发，因此无法获取其token id），并建立 GID和 $nft_{BC}^{I,?}$ 对应关系。这次操作将产生 $EX_{issue}$.</li>
</ul>
<h5><a class="header" href="#protocol-transfer-1" id="protocol-transfer-1">Protocol: Transfer</a></h5>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7fe8pswk9j3120050aac.jpg" alt="image-20190927191635665" /></p>
<p>解释：</p>
<p>在 chain $I$ 上 <em>sender</em> 调用 $iSC_I$ 中的 transfer方法，将 $nft_I^{x',n'}$ 发送给 <em>receiver</em></p>
<h5><a class="header" href="#protocol-redeem-1" id="protocol-redeem-1">Protocol: Redeem</a></h5>
<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7sznhfdu6j314w0q0n0c.jpg" alt="image-20191010114326817" style="zoom:50%;" />
<p>解释：</p>
<h6><a class="header" href="#redeemer-相关操作" id="redeemer-相关操作"><em>redeemer</em> 相关操作：</a></h6>
<ul>
<li><strong>burn</strong>( $nft_I^{x',n'}$, $GID$, $pk_B^{redeemer}$ ) : 发生在 chain $I$ 上。 <em>redeemer</em> 触发$bSC_I$ 的方法，将 $nft_I^{x',n'}$ 销毁，但保留销毁记录，$bSC_I$ 可以原子地检验 $GID$ 和 $nft_I^{x',n'}$ 对应关系。该操作将会产生交易 $T_I^{redeem}$ </li>
<li><strong>verifyIOp</strong>(burn,  $T_I^{redeem}$,  $\Delta_{redeem}$) : 发生在 Bridge Core内。用户将 $T_I^{redeem}$ 提交至 $vSC_I$ 中，如果 $T_I^{redeem}$ 真实地在 chain $I$ 上发生过并且满足最小需要延时 $\Delta_{redeem}$，即会根据 $GID$ 找到 对应的 $nft_{BC}^{I,?}$ 并根据自动补全成 $nft_{BC}^{I,n'}$ </li>
<li><strong>verifyBCOp</strong>(trigger, $EX_{redeem}$, $\Delta_{trigger}$) $\rightarrow T$ :  发生在 chain $B$ 内。<em>redeemer</em> 将 $EX_{redeem}$ 提交至chain $B$ 的 $iSC_B$ 内，如果$iSC_B$ 验证 $EX_{redeem}$ 的真实性即返回T，否则返回F。验证通过后，即通过调用issue方法，即释放 $nft_B^{x,n}$ 到 <em>redeemer</em> 在 chain $B$ 的地址上。</li>
</ul>
<h6><a class="header" href="#validator-相关操作-1" id="validator-相关操作-1"><em>validator</em> 相关操作：</a></h6>
<ul>
<li><strong>burnTransform</strong>($vSC_B,\ GID,\ nft_{BC}^{x,n},\ pk_B^{redeemer}$ ): <em>validator</em> 自动触发 $vSC_B$ 中的方法， 将 $nft_{BC}^{I,n'}$ 销毁同时产生 $nft_{BC}^{B,n}$, 表示在chain $B$ 上即将释放的nft的镜像。这次操作将产生 $EX_{redeem}$.</li>
</ul>
<h2><a class="header" href="#" id=""></a></h2>
<h2><a class="header" href="#iv-cross-chain-nft-standards" id="iv-cross-chain-nft-standards">IV. Cross-chain NFT Standards</a></h2>
<p>跨链环境下，NFT会出现在不同的区块链网络中，并且其可用状态可能不断变化，因此类似原来单链网络内的标准和方案(例如，Ethereum ERC20)，已经无法满足跨链NFT标准的需要。</p>
<p>跨链NFT标准面临的识别性和解析问题，需要新的解决方案和标准来解决。因此我们引入一个基于通证跨链证明的解析系统来解决通证跨链时的定位和解析需求，通过通证解析系统和域内唯一标识，我们可以存在与不同域的通证之间的关联关系映射起来，并标识他们之间的相同与不同。</p>
<h3><a class="header" href="#a-设计范围" id="a-设计范围">A. 设计范围</a></h3>
<ul>
<li>
<p>全局唯一标识和外部本地标识规范</p>
<p>为了将不同标准的通证标识符进行规范化，以提供识别和解析方法，与现有的标准进行很好的协调和对接，并满足社区基础设施建设的标准需求。识别标识分为全局唯一标识和外部本地标识。</p>
</li>
<li>
<p>NFT解析系统</p>
</li>
<li>
<p>NFT所有权管理</p>
</li>
<li>
<p>Inter-parachain NFT Transfers</p>
<p>通过引入一个关联的SPREE模块来帮助在不同的平行链之间进行跨链转账。</p>
</li>
</ul>
<h3><a class="header" href="#b-标准方案" id="b-标准方案">B. 标准方案</a></h3>
<p>基于跨链NFT协议的设计和方案基础，我们设计并提议了一个跨链NFT的标准提案，详细设计放在了 <a href="rfcs/./0013-darwinia-cross-chain-nft-standards.html">RFC-0013 Cross-chain NFT Standards</a>。</p>
<h2><a class="header" href="#参考-3" id="参考-3">参考</a></h2>
<p>[1] https://bitcoin.org/bitcoin.pdf</p>
<p>[2] https://github.com/ethereum/wiki/wiki/White-Paper</p>
<p>[3] https://github.com/EOSIO/Documentation/blob/master/TechnicalWhitePaper.md</p>
<p>[4] https://eips.ethereum.org/EIPS/eip-20</p>
<p>[5] https://eips.ethereum.org/EIPS/eip-721</p>
<p>[6] https://en.bitcoin.it/wiki/Hashed_Timelock_Contracts</p>
<p>[7] https://eprint.iacr.org/2018/643.pdf</p>
<p>[8] https://opensea.io/</p>
<p>[9] https://vitalik.ca/general/2018/04/20/radical_markets.html</p>
<p>[10] https://github.com/ethereum/wiki/wiki/Light-client-protocol</p>
<p>[11] https://elixir-europe.org/platforms/interoperability</p>
<p>[12] https://github.com/AlphaWallet/TokenScript</p>
<p>[13] https://github.com/darwinia-network/rfcs/blob/v0.1.0/zh_CN/0005-interstella-asset-encoding.md</p>
<p>[14] https://onlinelibrary.wiley.com/doi/pdf/10.1087/20120404</p>
<p>[15] https://wiki.polkadot.network/en/latest/polkadot/learn/spree/</p>
<p>[16] https://en.wikipedia.org/wiki/Unique_identifier</p>
<p>[17] https://en.wikipedia.org/wiki/Identifiers.org</p>
<p>[18] https://schema.org/</p>
<p>[19] https://medium.com/drep-family/cross-chains-a-bridge-connecting-reputation-value-in-silo-b65729cb9cd9</p>
<p>[20] https://github.com/paritytech/parity-bridge</p>
<p>[21] https://vitalik.ca/general/2018/04/20/radical_markets.html</p>
<p>[22] https://talk.darwinia.network/topics/99</p>
<h1><a class="header" href="#0011" id="0011">0011</a></h1>
<h2><a class="header" href="#概述" id="概述">概述</a></h2>
<p>针对XClaim框架中缺少针对NFT的喂价机制设计，本文提出通过哈伯格税模型的机制来解决价格发现问题。</p>
<h2><a class="header" href="#i-xclaim-based-nft-cross-chain-protocol" id="i-xclaim-based-nft-cross-chain-protocol">I. XClaim-Based NFT cross-chain protocol</a></h2>
<h3><a class="header" href="#a-区块链模型假设" id="a-区块链模型假设">A. 区块链模型假设</a></h3>
<blockquote>
<p>为了兼容 XClaim，这里对chain $B$ 和 chain $I$ 的假设和 XClaim一样，并不做更多的假设限制。</p>
</blockquote>
<p>基本假设：</p>
<ul>
<li>
<p><em>backing blockchain</em>，只有基本的账本功能的区块链，对于NFT跨链，唯一增加的假设就是 <em>chain $B$</em> 原生token就支持NFT；</p>
</li>
<li>
<p><em>Issuing blockchain</em> , 支持图灵完备的智能合约的区块链；</p>
</li>
</ul>
<p>在这里，我们构造出一个跨链场景：</p>
<p>Alice 在 <em>chain $B$</em> 上拥有 $nft_b^n$,  Dave在chain $I$ 上有足够的 $i$,</p>
<ol>
<li>Alice想在chain $I$ 上发行 $nft_b$ 对应的新NFT，即 $nft_i^{n'}$</li>
<li>Alice在拥有$nft_i^{n'}$ 之后，又想把它在chain $I$  上转移给 Bob</li>
<li>或者在某个稍晚的时刻，Bob想从chain $I$ 上把资产赎回到 chain $B$ ，再次获得 $nft_b^n$ </li>
</ol>
<p>为了实现以上场景，XClaim-based NFT cross-chain protocol需要实现三种协议：<em>Issue, Trasnfer, Redeem</em>. 为了简化模型，我们在此处省略手续费相关部分的细节。</p>
<h3><a class="header" href="#b-研究基础" id="b-研究基础">B. 研究基础</a></h3>
<p>如果以XClaim方案作为跨链的基本方案，那么在这个基础上，只需要解决NFT的定价问题，就可以解决系统的经济安全。</p>
<p>对于NFT的定价问题，目前中心化和去中心化交易所给出的解决方案就是交给市场。根据dapp数据统计网站显示，排名第一的NFT交易所Opensea[8]一天的日活用户仅为42，日交易笔数73. 即使也采用和XClaim相同的喂价方案Oracle, 在这样的市场面前，得到的价格也很难具有代表性。</p>
<p>并且，鉴于NFT的不可替代性，市场定价的方法也存在天然的悖论。即买卖成功才可以定价；但是买卖成功同时也意味着owner的转移。</p>
<p>目前对于NFT的定价问题，还没有成型的方案。</p>
<h4><a class="header" href="#b-i-什么是harberger-taxes" id="b-i-什么是harberger-taxes">B-I. 什么是Harberger Taxes</a></h4>
<p>市场和私有财产是两个通常被放在一起谈论的话题，在现在社会很难想象，如果只单独谈论其中的一点却不提及另一点。然而在十九世纪，很多欧洲的经济学者也是自由论者和平等主张者，那时拥抱市场同时对私有财产持怀疑态度是很正常的事情。</p>
<p>由此，实现一个包含市场但是却没有所有权的系统是完全可行的：在每年的结束，收集物品的价格，在第二年的一开始，物品属于出价更高的人。这样的系统虽然在现实中不可行，但是它有一个显著的优点：实现配置效率。每年，每件物品都属于可以从中获取最大价值的人（因此才愿意出更高的价格）。</p>
<p>Eric Posner 和 Glen Weyl, 《radical market》的作者提出了一个方案Harberger Taxes[9]：1. 所有人都为自己的财产评估一个价格  2. 所有人按评估价的百分比，例如2%进行交税  3. 其他人可以以不小于评估价的价格，随时买走自己的财产。这就强制所有人都必须公平客观地评估物品的价格，评估地过高，自己就要多缴税；评估地过低，其他人就可以获得消费者剩余。</p>
<h4><a class="header" href="#b-ii-harberger-taxes在跨链中的应用" id="b-ii-harberger-taxes在跨链中的应用">B-II. Harberger Taxes在跨链中的应用</a></h4>
<p>我们提议将Harberger Taxes应用于NFT的定价上。不同于将定价问题交给时间和市场，我们提议将定价问题交给跨链发起者自己。</p>
<p>因跨链并不需要涉及到NFT的交易，所以我们只应用Harberger Taxes的卖方估价并交税的部分，并不应用强制交易的部分。</p>
<p>大概的思路为，由跨链发起者为其需要跨链的在chain $B$ 上的NFT $nft_b$ 声明一个价格 $p$ ，并按照一定比例的价格支付跨链手续费；对应地，$vault$ 需要按价格在chain $I$ 上提供等值/超值于$p$ 的抵押 $i$，如果跨链操作正确完成，则跨链手续费将被支付给对应的 $vault$ ；如果存在恶意行为导致跨链失败并且$nft_b$ 的归属者发生错误转移，则抵押的 $i$ 将用于补偿跨链发起者的损失。</p>
<h3><a class="header" href="#c-组件定义" id="c-组件定义">C. 组件定义</a></h3>
<p>这里我们将部分遵从XClaim的声明方式，以保持延续性：</p>
<ul>
<li><em>Issuing blockchain</em>, the blockchain $I$, 跨链后的新NFT的发行链</li>
<li><em>backing blockchain</em>, the blockchain $B$, 跨链前NFT所在的链</li>
<li><em>NFT identifier</em>, $nft_b^{n}$， 表示在chain $B$ 上的原生的、标识为 $n$ 的NFT，出现在章节II中</li>
<li><em>NFT identifier</em>, $nft_i^{n'}$， 表示跨链后在chain $I$ 上新增发的、 标识为 $n$ 的NFT，出现在章节II中</li>
<li><em>native token on chain $I$</em>:  $i$</li>
<li>抵押token，$i_col$ , 表示在chain $I$ 上抵押的token</li>
</ul>
<p>系统参与方：</p>
<ul>
<li><strong>Requester</strong> :  在chain $B$ 上锁定 $nft_b^n$  并且希望在 $I$ 上获得新发行的$nft_i^{n'}$ ；</li>
<li><strong>Sender</strong>： 在  $I$ 上拥有$nft_i^{n'}$ 并且可以转移它的所有权给其他人；</li>
<li><strong>Receiver</strong>： 在 $I$ 接受并且获取 $nft_i^{n'}$ 的所有权的人；</li>
<li><strong>Redeemer</strong>： 在 $I$ 上销毁 $nft_i^{n'}$ ，而后在 $B$ 上释放 $nft_b^n$；</li>
<li><strong>vault</strong>： 不需要信任的第三方，保证 <em>Issue</em> 和 <em>Redeem</em> 时整个系统的经济安全；</li>
<li><strong>Issuing Smart Contract (iSC)</strong>：在 $I$ 上完全公开的、负责管理$vault$ 名单并负责发行NFT资产$nft_i$ 的智能合约</li>
<li><strong>backing Smart Contract(bSC)</strong>: 在 $B$ 上完全公开的、负责管理冻结后的NFT资产 $nft_b$ 的智能合约 （出现在章节III）</li>
</ul>
<p>其中，<em>Requester, redeemer, vault</em> 必须在 <em>chain $I$ 和 chain $B$</em> 上都有对应的公私钥；<em>Sender, Receiver</em>只需要持有在 $I$ 上的公私钥；<em>iSC</em> 是在 $I$ 上完全公开的、可审计的智能合约；<em>bSC</em>是在 $B$ 上完全公开的、可审计的智能合约。</p>
<h3><a class="header" href="#d-初步实现方案" id="d-初步实现方案">D. 初步实现方案</a></h3>
<h4><a class="header" href="#protocol-issue-2" id="protocol-issue-2">Protocol: Issue</a></h4>
<blockquote>
<p>Alice (requester) 把  $nft_b^n$ 在 $B$ 上锁定在 $vault$，为了在 $I$ 上创造 $nft_i^{n'}$.</p>
</blockquote>
<p>(i) <em><strong>准备</strong></em>。Alice 预先声明一个价格 $p$,  确认 iSC 有效并且在 iSC 中寻找有足额/超额抵押 ($i_col$) 的 $vault$.</p>
<p>(ii) <em><strong>锁定</strong></em>。Alice 把 $nft_b^n$ 转移给 $vault$，同时声明自己在 $I$ 上的地址；并且支付跨链手续费；</p>
<p>(iii) <em><strong>发行</strong></em>。$vault$ 向iSC发送签名消息: 同意向Alice在 $I$ 上的地址发行新资产， iSC 在确认 $vault$ 的签名后，在Alice的地址上发行 $nft_i^{n'}$</p>
<h4><a class="header" href="#protocol-transfer-2" id="protocol-transfer-2">Protocol: Transfer</a></h4>
<blockquote>
<p>Alice (sender) 在 chain $I$ 发送 $nft_i^{n'}$ 给 Bob (receiver) </p>
</blockquote>
<p>(i) <em><strong>转移</strong></em>。Alice在 $I$ 上把 $nft_i^{n'}$ 在 iSC中，把所有权转移给 Bob，参考ERC721.</p>
<p>(ii) <em><strong>见证</strong></em>。当 $nft_i^{n'}$ 在 iSC 中的所有权发生了转移时，相应的 $vault$ 应当可以见证觉察。此时，当Alice再想把 $nft_i^{n'}$ 赎回时，$vault$ 在 iSC 中发现 $nft_i^{n'}$ 的所有权已经转移给Bob之后，应当禁止该交易。</p>
<p>需要补充的是，在系列操作的过程中，$nft_i^{n'}$ 的价格可能发生波动，该NFT的当前所有人可随时为其声明新的价格，相应地，$vault$ 需要满足质押。</p>
<h4><a class="header" href="#protocol-redeem-2" id="protocol-redeem-2">Protocol: Redeem</a></h4>
<blockquote>
<p>Bob想把 $nft_i^{n'}$ 从 $I$ 中赎回到 $B$ 中时，Bob需要把 $nft_i^{n'}$ 锁定在 iSC 里，这样 $vault$ 在 $B$ 上就会把 $nft_b^n$ 释放给 Bob. 然后在 $I$ 中销毁$nft_i^{n'}$。</p>
</blockquote>
<p>(i) <em><strong>准备</strong></em>。Bob需要现在 $B$ 上创建地址，持有对应私钥。</p>
<p>(ii) <em><strong>锁定</strong></em>。 Bob在 $I$ 上把 $nft_i^{n'}$ 锁定在 iSC 中，发起赎回请求，请求中应包含 Bob 在 $B$ 上的地址。并且，$vault$ 应当对这一过程保持觉察。</p>
<p>(iii) <em><strong>释放</strong></em>。$vault$ 可以在 iSC 中验证锁定操作和赎回请求， 之后在 $B$ 上将对应的 $nft_b^n$ 发送给 Bob的地址。</p>
<p>(iv) <em><strong>销毁</strong></em>。 $vault$ 提交 在 $B$ 上的释放证明 (proof) 给 iSC，iSC在验证 proof 之后自动销毁 $nft_i^{n'}$ 并且允许 $vault$ 解冻对应的 $i_col$</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g74nx78muuj31940eon04.jpg" alt="image-20190918160246144" /></p>
<p>​																						  (图片来自XClaim，有待修改)</p>
<h3><a class="header" href="#c-design-roadmap" id="c-design-roadmap">C. Design Roadmap</a></h3>
<p>在之前的示例说明中，都默认了单 $vault$ 模式。 XClaim本身对于这种模式就有了扩展的、更加去中心化的解决方案，即引入 <em>multi-vault</em>，允许任何人抵押 $i_col$ 成为 $vault$，从而最大程度减轻单点故障对整个系统带来的影响。因此XClaim-based NFT跨链方案，天然支持这种扩展。</p>
<p>然而，由于NFT的不可替代性，导致NFT的估价不具备连续性和可预测性，价格上有很大概率存在剧烈波动，从而影响系统的安全性。为了尽量减低NFT价格波动对系统安全性的冲击，我们将在III中引入全新的解决方案，通过基于全新且合理的区块链假设，不依赖 $vault$ ，即在 <em>non-vault</em> 的情况下，实现跨链安全。</p>
<ol>
<li>通过继承XClaim的扩展方案，首先，尽可能减低对$vault$ 的信任依赖，甚至实现0信任依赖，来实现整个系统的健壮性。在这里，我们引入 $chain\ relay$ (章节III) 来为 iSC 提供 chain $B$ 的上的区块和交易证明，对任何人公开可查。</li>
<li>在整个跨链过程中，$vault$ 要保持参与，为了防止单个 $vault$ 可能发生的单点故障，这里我们同样采取和XClaim相同的做法，开放 $vault$ 的注册，允许任何愿意抵押 $i_col$ 的人或者机构都可以成为 $vault$.</li>
<li>前述，即使NFT价格可以被正确评估，但是由于NFT价格的不连续性和波动幅度大的特点，使得 $vault$ 的抵押也可能存在较大幅度的波动。因此，在章节III中，我们引入了没有 $vault$ 的跨链解决方案。这对chain $B$ 会有更高的假设限制，技术维护上的成本也会更高一些。但是相比于XClaim沉淀了大量的抵押资金，然而在经济上目前还没有可持续性的激励方案，我们认为技术维护上多出的成本，远远小于抵押资金的时间成本。值得尝试。</li>
</ol>
<h1><a class="header" href="#ii-其他" id="ii-其他">II. 其他</a></h1>
<p>[WIP]</p>
<h1><a class="header" href="#0012" id="0012">0012</a></h1>
<h2><a class="header" href="#i-abstract" id="i-abstract">I. Abstract</a></h2>
<p>XClaim[5] 针对 ACCS 的缺点，设计了通用的、高效低成本的跨链框架，并提出了Cryptocurrency-Bakced Assets (CBAs)的概念。其设计主要分成三个部分：</p>
<ul>
<li>提出的CBA概念对跨链资产和原生资产的关系做了清晰的概括，是原生资产在另外一个区块链网络中存在形式的精简表达。</li>
<li>在发行链(Issuing Blockchain)一端，通过借助Chain Relay对另外一个链上的交易证明进行存在性和共识性的直接验证，而无需信任第三方。</li>
<li>在背书链(Backing Blockchain)一端，通过引入Vault、质押物(Collateral)和喂价等经济机制，对赎回过程的安全性实现了理性经济假设下的保证。由于存在质押物和喂价机制的约束，所以只能支持流动性较好的Fungible Token。</li>
</ul>
<p>XClaim 虽然某种程度上解决了 ACCS 的缺点，但是也存在其自身的局限性：只针对Fungible Token有效，不支持NFT和其他流动性较差无法喂价和平仓的Fungible Token。此外，XClaim方案中因为Vault的质押物在跨链资产赎回之前都是锁定的，导致存在较高的质押成本，抵押物可能存在收益率不足的问题。</p>
<p>针对XClaim的以上问题，本文在保留CBA概念和大部分发行链的设计的同时，将背书链一端进行重新设计，增加对Backing Blockchain引入更多合理假设，即支持智能合约和Chain Relay(非BTC)，在背书链一端引入Chain Relay来验证发行链的交易，同时对背书锁定资产的赎回进行链上合约化的约束。通过这样的新方式，去除Vault、流动性质押、喂价等设计和模块，实现了对更广泛的Token的支持，包括NFT和流动性不好的Fungible Token。</p>
<h2><a class="header" href="#ii-introduction" id="ii-introduction">II. Introduction</a></h2>
<p>对于不同区块链上的token交换，目前虽然中心化交易所可以帮助执行，但是这样的服务需要高度的信任，且易发生主动作恶、单点故障等问题。随着Cosmos、Polkadot这样一批优秀的跨链项目的落地，架构在跨链基础设施之上的去中心化token流通协议/方案也成为重要的研究内容。</p>
<p>在已有的方案中，atomic cross-chain swaps (ACCS) 是最早提出的可行性方案，但由于其跨链效率低、成本高，实际使用场景并不多。随后，XClaim (Cross Claim) 针对 ACCS 的缺点，提出了通用的、高效低成本的跨链框架，使用了Cryptocurrency-Bakced Assets (CBAs). </p>
<p>XClaim 虽然某种程度上解决了 ACCS 的缺点，但是也存在其自身的局限性：只针对Fungible Token有效，并且。目前针对NFT的跨链流通还没有通用框架。本文以双链互跨为例，通过对Backing Blockchain引入更多假设，即假设Backing Blockchain支持智能合约，提出基于双Chain Relay的改进版通用XClaim方案（同时适用于Fungible Token和NFT）。</p>
<p>该方案将展示Two chainRelay Model的设计思路和过程实现。<a href="https://eprint.iacr.org/2018/643.pdf">XClaim</a>跨链方案已经可以保证了在大部分场合下的NFT的跨链安全操作，但是依然无法保证通证资产价格产生剧烈波动时，整个系统的鲁棒性和可持续性。</p>
<p>同时，本文还将着重分析chainRelay的实现成本和其改进方案，目前改进思路包括两个方案的探讨，其一，通过批量提交<em>block headers</em>，或对<em>block headers</em>构建<em>merkle tree</em>的方式压缩成本，其二，通过借助零知识证明的技术，将上传<em>block headers</em>成本降低，并提高链上验证交易的速度。</p>
<h2><a class="header" href="#iii-overview" id="iii-overview">III. Overview</a></h2>
<p>在这一章节，我们首先回顾和定义一些XClaim中与本文有关的概念，以及系统的模型和参与其中的角色。</p>
<h3><a class="header" href="#a-cryptocurrency-backed-assetscba" id="a-cryptocurrency-backed-assetscba">A. Cryptocurrency-backed Assets(CBA)</a></h3>
<p><strong>Definition.</strong> We define <em>cryptocurrency-backed assets</em> (CBAs) as assets deployed on top of a blockchain <em>I</em> that are backed by a cryptocurrency on blockchain <em>B</em>. We denote assets in <em>I</em> as <em>i</em>, and cryptocurrency on <em>B</em> as <em>b</em>. We use <em>i(b)</em> to further denote when an asset on <em>I</em> is backed by <em>b</em>. We describe a CBA through the following fields:</p>
<ul>
<li>
<p><em>issuing blockchain</em>, the blockchain <em>I</em> on which the CBA <em>i(b)</em> is issued.</p>
</li>
<li>
<p><em>backing blockchain</em>, the blockchain <em>B</em> that backs <em>i(b)</em> using cryptocurrency <em>b</em>.</p>
</li>
<li>
<p><em>asset value</em>, the units of the backing cryptocurrency <em>b</em> used to generate the asset <em>i(b)</em>.</p>
</li>
<li>
<p><em>asset redeemability</em>, whether or not <em>i(b)</em> can be redeemed on <em>B</em> for <em>b</em>.</p>
</li>
<li>
<p><em>asset owner</em>, the current owner of <em>i(b)</em> on <em>I</em>.</p>
</li>
<li>
<p><em>asset fungibility</em>, whether or not units of <em>i(b)</em> are inter-</p>
<p>changeable.</p>
</li>
</ul>
<h3><a class="header" href="#b-system-model-and-actors" id="b-system-model-and-actors">B. System Model and Actors</a></h3>
<p>XCLAIM operates between a backing blockchain <em>B</em> of cryptocurrency <em>b</em> and an issuing blockchain <em>I</em> with underlying CBA <em>i(b)</em>. To operate CBAs, XCLAIM further differentiates between the following actors in the system:</p>
<ul>
<li>
<p>CBA Requester. Locks b on B to request i(b) on I.</p>
</li>
<li>
<p>CBA Sender. Owns i(b) and transfers ownership to another</p>
<p>user on I.</p>
</li>
<li>
<p>CBA Receiver. Receives and is assigned ownership over</p>
<p>i(b) on I.</p>
</li>
<li>
<p>CBA Redeemer. Destroys i(b) on I to request the corre-</p>
<p>sponding amount of b on B.</p>
</li>
<li>
<p>CBA Backing Smart Constract(bSC). A public smart contract responsible for trust-free locking/releasing <em>b</em> as protocol design requires and liable for fulfilling redeem requests of i(b) for b on B, with support of chain relay to honestly follow the instructions from redeem requests from I. <em>bSC</em> is registered on <em>I</em> so that the issuing contracts on <em>I</em> will know the transactions happen to bSC.</p>
</li>
<li>
<p>Issuing Smart Contract (iSC). A public smart contract responsible for managing the correct issuing and exchange of i(b) on I. The <em>iSC</em> is required to register on <em>bSC</em> so that the backing contracts on <em>B</em> will know the transactions happen to <em>iSC</em>, in this way, <em>iSC</em> ensures correct behaviour of the <em>bSC</em>, e.g. the release action in redeem protocol.</p>
<p>To perform these roles in XCLAIM, actors are identified on a blockchain using their public/private key pairs. As a result, the requester, redeemer must maintain key pairs for both blockchains B and I. The sender and receiver only need to maintain key pairs for the issuing blockchain <em>I</em>. <em>iSC</em> exists as a publicly verifiable smart contract on <em>I</em>, and <em>bSC</em> exists as a publicly verifiable smart contract on <em>B</em>.</p>
</li>
</ul>
<h3><a class="header" href="#c-什么是-chain-relay" id="c-什么是-chain-relay">C. 什么是 <em>chain relay</em></a></h3>
<p>XClaim 给出了对 <em>chain relay</em> [7]的定义：</p>
<blockquote>
<p>Chain relays: Cross-Chain State Verification. It is capable of interpreting the statte of the backing blockchain B and provide functionality comparable to an SPV or light client[10].</p>
</blockquote>
<p>因此，<em>chain relay</em> 可以被认为是由包含root of merkle tree的区块头组成。它为 iSC 提供了两种功能： <em>交易存在证明</em> 以及 <em>共识证明</em>。</p>
<ul>
<li><em><strong>交易存在证明</strong></em>： <em>chain relay</em> 存储着区块链的每一个区块头，以及区块头里的root of merkle tree. 在提供merkle tree路径的情况下，这已经足够可以证明一笔交易是否存在于这条链的某个区块中。</li>
<li><em><strong>共识证明</strong></em>： 以比特币为例，因为每个节点通常不能即时看到全网的情况，因此经常会发生产生孤块，又在重组中被丢弃的情况。为了避免这种情况带来的攻击/漏洞，<em>chain relay</em> 必须要验证给定的区块头是否为完整区块链的一部分，例如被大部分节点认可。对于共识为Proof-of-Work的区块链，<em>chain relay</em> 必须：(i) 知道挖矿难度调整策略  (ii) 验证收到的区块头是否在具有最多累计工作量证明的链上。 对于共识为Proof-of-Stake的区块链，<em>chain relay</em> 必须：(i) 知道协议要求/staking的阶段，例如epoch  (ii) 验证区块头中验证人签名数量是否满足区块的阈值要求。 </li>
</ul>
<p><img src="https://github.com/darwinia-network/rfcs/raw/master/RFC/zh_CN/images/chain_relay.svg?sanitize=true" alt="Chain Relay" /></p>
<p>[TODO: 图片来自于网络]</p>
<h3><a class="header" href="#d-区块链模型和假设" id="d-区块链模型和假设">D. 区块链模型和假设</a></h3>
<p>在目前已经上线的区块链项目中，几乎没有NFT作为链的原生资产的，所有的NFT几乎都是在智能合约内实现的。因此，对原生资产所在的chain $B$, 可以引入全新且合理的假设：</p>
<ul>
<li><em>Backing blockchain</em> 和 <em>Issuing blockchain</em>:  都支持图灵完备的智能合约</li>
</ul>
<p>这样我们就可以通过在 $B$ 和 $I$ 上放置独立的智能合约 bSC 和 iSC 来提供更强的技术约束，保证跨链的安全性。</p>
<h3><a class="header" href="#e-system-goals" id="e-system-goals">E. System Goals</a></h3>
<ol>
<li>Support General Tokens
<ul>
<li>Workable for NFT</li>
<li>Workable for Fungible Tokens without liquidations on outside exchanges.</li>
</ul>
</li>
<li>Economic Feasible
<ul>
<li>Backing contract does not require to provide a lot of collateral for the safety of redeem protocol</li>
<li>Feasible solutions for to support running low cost chain relay on backing blockchain.</li>
</ul>
</li>
<li>Securty Properties(Ignore, refer the section in XClaim paper):
<ul>
<li>Audiability</li>
<li>Consitency</li>
<li>Redeemability</li>
<li>Liveness</li>
<li>Atomic Swaps</li>
<li>Scale-out</li>
<li>Compatiblity</li>
</ul>
</li>
</ol>
<h2><a class="header" href="#iv-backing-contract-solution" id="iv-backing-contract-solution">IV. Backing Contract Solution</a></h2>
<p><strong>Backing Contract Solution</strong>(two chain relay model)通过在Backing Blockchain上引入一个支持chain relay的智能合约，以实现背书资产<em>b</em>的托管锁定和赎回释放功能。因为有了chain relay的支持，所以Backing Contract将可以忠实的执行发行链<em>I</em>上的赎回指令，而不需担心资产的安全问题，也不用要求Backing Contract需要质押资产，因为Backing Contract 是可审计的，并且注册在<em>iSC</em>中，因此避免了中间人信任风险和单点故障问题。</p>
<p>相较于XClaim原始的方案，我们引入了完全无 $vault$ 质押的跨链方案，通过在backing blockchain上引入chain-relay来保证可赎回性和安全性。<em>chainRelay</em> 可以提供区块链的交易存在证明和共识证明，在XClaim的方案中，对chain $B$ 没有任何额外的要求，导致在 chain $B$ 上的安全只能由在 chain $I$ 上抵押 $i_col$ 的 $vault$ 来提供。通过III-D中对 chain $B$ 引入的新的假设约束，可以在转接桥中实现<em><strong>bSC + iSC</strong></em>双向互相验证和互操作。例如，在赎回协议中， chain $B$ 上的资产安全可以非互操作性地实现，降低对 $vault$ 的依赖。</p>
<h3><a class="header" href="#a-protocols" id="a-protocols">A. Protocols</a></h3>
<p>本方案提供五个协议：Register, Issue, Transfer, Swap and Redeem.</p>
<p><strong>Protocol: Register.</strong> <em>bSC</em>需要在<em>iSC</em>中注册，<em>iSC</em>也需要在<em>bSC</em>中注册，这个相互注册过程需要公开可审计的，并通过注册完成之后的关闭外部(中心化的key的)注册权限的方式完成注册。Alice deploy an backing contract on B, and Dave deploy and issuing contract on I, and the backing contract and issuing contract require to register with each other.</p>
<ol>
<li>Deploy. First, Alice deploy the backing contract on B, and Dave deploy the issuing contract on I.</li>
<li>Verify. Alice and Dave verify the counterpart's smart contracts.</li>
<li>Register&amp;Setup. Alice register Backing contract on I and associate with Issuing contract. Dave register Issuing contract on B and associate with backing contract.</li>
<li>Finish. Backing and Issuing Contracts finish the permission-less register process. (Some permission closing TX may be required.)</li>
</ol>
<p><strong>Protocol: Issue.</strong> Alice (<em>requester</em>) locks units of <em>b</em> with the <em>backing contract</em> on B to create <em>i(b)</em> on I:</p>
<ol>
<li>Lock. Alice generates a new pulic/private key pare on <em>I</em> and locks funds <em>b</em> with the backing contract on B in a publicly verifiable manner. i.e., by send <em>b</em> to the lock contract associated with backing contract. As part of locking these funds, Alice also specifies where the to-be-generated <em>i(b)</em> should be sent, i.e, Alice associates her public key on <em>I</em> with the transfer of <em>b</em> to the lock contract (linked to backing contract).</li>
<li>Check Finalization. Alice (or her running client) check the the finalization vailid status of the lock transaction before she do the next step.</li>
<li>Send Lock TX Proof. Alice send the lock transaction proof to <em>Issuing Contract</em> on <em>I</em> , the instruction in the proof and transaction also include the issue instructions.</li>
<li>Verify &amp; Issue. After the issuing contract confirms via the TX proof and verify the validation that Alice has correctly locked her funds and forwards Alice's public key on I to iSC. The iSC verifies the proof, then issues and send i(b) to Alice, such that $||i(b)|| = ||b||$</li>
</ol>
<p>**Protocol: Transfer.**Alice (<em>sender</em>) transfers <em>i(b)</em> to Dave (<em>receiver</em>) on I: </p>
<ol>
<li><em>Transfer.</em> Alice notifies the iSC that she wishes to transfer her i(b) to Dave (public key) on I. The state of the iSC is updated and Dave becomes the new owner of i(b). </li>
<li><em>Witness.</em> The backing contract witnesses the change of ownership on I through iSC, and no longer allows Alice to withdraw the associated amount of locked b on B. The process for any further transfers from Dave to other users is analogous. </li>
</ol>
<p><strong>Protocol: Swap</strong>.Alice (sender) atomically swaps i(b) against Dave’s (receiver) i on I: </p>
<ol>
<li>
<p><em>Lock.</em> Alice locks i(b) with the iSC. </p>
</li>
<li>
<p><em>Swap.</em> If Dave locks the agreed upon units of i (or any other asset on I) with the iSC within delay ∆swap, the iSC updates the balance of Dave, making him the new owner of i(b), and assigns Alice ownership over i. </p>
</li>
<li>
<p><em>Revoke.</em> If Dave does not correctly lock i with the iSC within ∆swap, the iSC releases locked i(b) to Alice. </p>
</li>
<li>
<p><em>Witness.</em> If the swap is successful, the backing contract witnesses the change of ownership of i(b) and no longer allows Alice to redeem the associated amount. </p>
</li>
</ol>
<p>**Protocol: Redeem.**Dave (redeemer) burn i(b) with the iSC on I to receive b from the vault on B:</p>
<ol>
<li>
<p>Burn &amp; Redeem. Dave creates a new public/private key pair on B. and locks <em>i(b)</em> with the <em>iSC</em> on I and requests the redemption of <em>i(b)</em>. There by, Dave also specifies his new public key on <em>B</em> as the target for the redeem.</p>
</li>
<li>
<p>Check Finalization. Dave (or her running client) check the the finalization valid status of the lock transaction before she do the next step.</p>
</li>
<li>
<p>Send Burn TX Proof. Dave send the burn transaction proof to <em>bSC</em> on <em>B</em> , the instruction in the proof and transaction also include the redeem instructions.</p>
</li>
<li>
<p>Verify &amp; Release.  After the backing contract confirms via the TX proof and verify the validation that Dave has correctly locked her funds and forwards Dave's public key on B to <em>bSC</em>. The <em>bSC</em> verifies the proof, then release funds <em>b</em> to Dave's specified public key on <em>B</em>, such that $||b|| = ||i(b)||$</p>
</li>
</ol>
<p><img src="https://github.com/darwinia-network/rfcs/raw/master/RFC/zh_CN/images/xclaim_new_protocol_overview.png" alt="Solution Protocols" /></p>
<h3><a class="header" href="#b-issue-contract" id="b-issue-contract">B. Issue Contract</a></h3>
<p>由于有了Backing Contract，并消除了只需要质押资产的部分，因为相较于原先XClaim的方案，新的Issuing Contract得到了很大的简化。</p>
<p><img src="https://github.com/darwinia-network/rfcs/raw/master/RFC/zh_CN/images/issuing_contract.png" alt="Issuing Contract" /></p>
<h3><a class="header" href="#c-backing-contract" id="c-backing-contract">C. Backing Contract</a></h3>
<p>Backing Contract用于替换原先XClaim中Vault的部分，并增加了智能合约和chain relay支持，通过在Backing Blockchain中引入chain relay，当发生赎回时，Backing Contract能够监听到Issuing Blockchain上的销毁动作，并进行交易验证，确认之后进行相应的背书资产释放动作。</p>
<p><img src="https://github.com/darwinia-network/rfcs/raw/master/RFC/zh_CN/images/backing_contract.png" alt="Backing Contract" /></p>
<h4><a class="header" href="#d--chain-relay-如何去信任" id="d--chain-relay-如何去信任">D.  <em>chain relay</em> 如何去信任</a></h4>
<p>这里以章节IV.A中的 <em>Protocol Issue</em> 为例，当 <em>requester</em> 把 $b$ 锁定在 $bSC$ 时，会产生一笔交易: $lock(backing_contract_address, lock_amount) - &gt; T_l$ ，随后backing chain relay的 <em>witness</em> 会向 <em>chain relay</em> 提交这笔交易$T_l$ ，之后 <em>chain relay</em> 会检验 $T_l$ 确实是存在于给定区块的交易中(交易存在证明)，这个区块也存在于最长链中并有良好的终结性（共识证明），那么就证明背书资产&amp;&amp;b已经被安全地锁定了。如果验证通过，会原子地触发 <em>iSC</em> 中的资产发行操作。</p>
<h2><a class="header" href="#v-darwinia-bridge-core---chain-relay-topology-optimization" id="v-darwinia-bridge-core---chain-relay-topology-optimization">V. Darwinia Bridge Core - Chain Relay Topology Optimization</a></h2>
<p>在两条公链中跨链转移token，需要在chain $I$ 维护 <em>chain relay</em> 的成本是很高的，例如以太坊上每笔交易需要gas。如果把两条公链之间的跨链行为扩展到任意 $n$ 公链的话，那么每条链上都需要单独维护 $n-1$ 个 iSC，总共将需要$C_n^2$个chain relay合约。为了降低系统的维护成本，考虑在基于substrate的平行链上实现跨链的核心功能。</p>
<h3><a class="header" href="#a-darwinia-bridge-core-架构" id="a-darwinia-bridge-core-架构">A. <em>Darwinia Bridge Core</em> 架构</a></h3>
<p>那么整个系统的架构如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7fe8rjjzvj30kb0bfgmc.jpg" alt="chain-relay-framework" /></p>
<p>图中 <strong>Bridge Core</strong> 即为平行链上包含通证跨链和各chain relay的核心模块；<strong>vSC</strong> 为 <strong>Bridge Core</strong> 的对应链的资产的发行模块。和以前的跨链方案不同的是，在上图的架构中，所有链的token需要先跨入<strong>Bridge Core</strong>, 而后在 <strong>Bridge Core</strong> 内部转换到目的公链对应的iSC 中，最后再在对应公链上发行对应的资产，整个跨链操作即完成。</p>
<h3><a class="header" href="#b-overview" id="b-overview">B. Overview</a></h3>
<p>[WIP]</p>
<h2><a class="header" href="#vi-chain-relay-maintenance-cost-and-improments" id="vi-chain-relay-maintenance-cost-and-improments">VI. Chain Relay Maintenance Cost and Improments</a></h2>
<p>与XClaim方案相比，最终的区别是在Backing Blockchain中引入了Chain Relay和智能合约，用于验证交易存在证明和共识证明。这个方案最大的一个挑战就是就是如何降低维护chain relay的成本，尤其是像以太坊这样的燃料费比较贵的区块链网络。</p>
<p>为了验证交易，像Bitcoin和以太坊需要节点来验证一条链是有效的，其中牵涉到下载并并验证区块的有效性，可能会花费服务器数小时的时间和很多的带宽和存储，不用说链上的合约，即使是像普通的移动端这样仅有有限资源的客户端都无法支持。因此像Bitcoin和以太坊这样的大部分公链提供了轻客户端，也就是SPV(Simplified payment verification)客户端，可以只需要下载区块头就可以进行交易验证。但是即使如此，简单的SPV客户端仍需要下载很多的区块头数据，面对智能合约高昂的燃料费来说，实现起来仍然不切实际。</p>
<p>因此，本章节将注重于对不同的Chain Relay实现进行评估和分析，以求找到链上成本最低的方案。</p>
<h3><a class="header" href="#a-cost-estimation" id="a-cost-estimation">A. Cost Estimation</a></h3>
<p>根据FlyClient[6]的描述，至2019年7月，一个以太坊的SPV客户端需要下载并存储4G的数据，如果采取类似的结构和设计，一个链上Chain Relay所需要下载并存储存储的数据也基本线性相关。</p>
<p>另一个可以评估的方案是<a href="rfcs/%5Bhttp://btcrelay.org%5D(http://btcrelay.org/)">BTCRelay</a>的成本。[WIP]</p>
<h3><a class="header" href="#b-improvements-using-flyclient6" id="b-improvements-using-flyclient6">B. Improvements using FlyClient[6]</a></h3>
<p>FlyClient[6]介绍了一种新的交易验证的轻客户端方案，可以支持多种区块链网络，包括POW区块链和POS区块链。</p>
<p>目前阶段，主要SPV客户端和BTCRelay方案的是，因为需要存储每一个区块头，导致其算法需要的存储和带宽要求是线性增长的。Fly Client通过组合 Merkle Moutain Range(MMR)<a href="https://github.com/darwinia-network/rfcs/raw/master/RFC/zh_CN/images/issuing_contract.png">2</a>，最佳概率块抽样(Optimal probabilistic block sampling)，Fiat–Shamir heuristic等技术，可以实现算法性能达到对数级，也就是在每次执行校验期间只需要下载对数个区块头。</p>
<p>详细设计可参考<a href="https://eprint.iacr.org/2019/226">FlyClient: Super-Light Clients for Cryptocurrencies</a></p>
<p>FlyClient提供了super light client的方案，但是Chain Relay需要在区块链内置合约(模块)或者用户合约中实现super light client，因此在设计方案上需要增加一些考虑点：</p>
<ul>
<li>
<p>Asymptotically and on Demand Proof Summit and Challenge Time</p>
<p>ChainRelay提交块头的如果只是一个人，则无法确认是诚实或是作恶的，或者说即使是善意的，提交的头也可能由于自然分叉而无效。在轻钱包协议中一个重要假设是轻钱包可以和多个全节点连接获得数据，并且至少其中一个是诚实的。所以，在我们的实现中，只有一个人提交头类似与只有一条连接，不足以确保数据的有效性。因此在用户使用这个ChainRelay的最新区块头及相关默克尔证明之前，需要增加一个Challenge时间，也就是最新的区块头被提交后，处于质疑状态，需要有一个challenge时段，在此时间过后没有人提交反对块（符合块基本交易且拥有更高难度，但MMR中不包含质疑块）或者收到赞同块（难度更高，但是MMR包含质疑块），最新提交的区块才被确认。此时，用户将可以使用这个Chain Relay验证在此最新块之前发生的交易是否存在。</p>
<p>为了防止攻击者攻击，在提交块时需要附带一定金额的押金，在块被信任后，押金返回并附带一定比例的手续费池金额作为奖励；如果块被否决，则押金扣除，扣除的押金一部分进入手续费池，一部分直接奖励否决块的提交人（否决块也需要被信任后才成为否决块）。</p>
</li>
<li>
<p>External Blockchain HardFork和治理机制</p>
<p>一些公链可能会出现硬分叉的情况，这些硬分叉可能会导致共识机制的改变，相应的，其轻节点也需要升级，但是Chain Relay一般以去中心化的智能合约形式存在，例如在跨链转接桥中为去中心化的背书技术提供支持。如果提供升级权限账户，就会削弱其去中心化程度并引入单点故障，如果不提供，则改Chain Relay将升级以应对外部链的硬分叉。因此需要引入治理机制来处理升级问题。</p>
<p>一般来说建议在应用状态验证合约进行治理升级的支持，例如如果出现硬分叉，则实现一个新的Chain Relay并部署，这个新的Chain Relay的Genesis则指向硬分叉块，所有依赖这个Chain Relay的应用状态验证合约，通过调整其Chain Relay指向逻辑，在硬分叉时，将旧的Chain Relay替换为新的Chain Relay，从而在保证Chain Relay去中心化的同时，提供应用层面升级的灵活性，应用层面可以选择应用不同的治理机制以及在治理和去中心化之间进行权衡。</p>
</li>
<li>
<p>On-chain Crypto Verification Support</p>
<p>Chain Relay需要对外部链上的交易证明进行验证，但是由于是在不同的链上，Chain Relay所在链可能不支持外部链交易所需的加密库，例如Ethereum 1.0目前还不支持BLS算法。因此如果需要广泛的支持不同的公链，需要考虑Chain Relay运行链是否支持相应的加密库。</p>
</li>
<li>
<p>Consensus Support</p>
<p>在Fly Client中，只针对类似Bitcoin和Ethereum这样的POW链提供了设计，针对其他的区块链共识(Poof of X)，例如POS，DPOS, PBFT等则没有详细描述，因此需要针对这些共识算法，设计相应的Super Light Client解决方案。[WIP]</p>
<p>对于Darwinia 来说，为了方便的在不同的公链上开发针对Darwinia的Chain Relay，并保证较低的成本和复杂度，因此需要将Darwinia的共识算法设计成Super Light Client Friendly的共识算法。[WIP]</p>
</li>
</ul>
<h3><a class="header" href="#c-improvements-using-zero-knowledge-proofs" id="c-improvements-using-zero-knowledge-proofs">C. Improvements using Zero-knowledge Proofs</a></h3>
<p>[WIP]</p>
<h2><a class="header" href="#vi-参考" id="vi-参考">VI. 参考</a></h2>
<ol>
<li>https://github.com/sec-bit/zkPoD-lib</li>
<li>https://github.com/mimblewimble/grin/blob/master/doc/mmr.md</li>
<li>https://github.com/ipfs/specs/tree/master/merkledag</li>
<li>https://hackernoon.com/ipfs-and-merkle-forest-a6b7f15f3537</li>
<li>XClaim, https://eprint.iacr.org/2018/643.pdf</li>
<li>FlyClient, https://eprint.iacr.org/2019/226</li>
<li>https://zhuanlan.zhihu.com/p/72620891</li>
<li>https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012715.html</li>
<li><a href="https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic">Fiat Shamir heuristic</a></li>
<li>https://medium.com/blockchain-research-newsletter/blockchain-research-newsletter-3-nipopow-and-flyclient-ac202f7624a7</li>
<li>https://blog.kyber.network/waterloo-a-decentralized-practical-bridge-between-eos-and-ethereum-1c230ac65524</li>
<li>https://medium.com/@loiluu/peacerelay-connecting-the-many-ethereum-blockchains-22605c300ad3</li>
<li>https://steemit.com/eos/@attic-lab/eos-io-consensus-algorithm</li>
</ol>
<h1><a class="header" href="#0013" id="0013">0013</a></h1>
<blockquote>
<p>Cross-chain NFT Standards</p>
</blockquote>
<h2><a class="header" href="#i-概述-1" id="i-概述-1">I. 概述</a></h2>
<p>为了方便的标记一个物品或者一个资产，我们会用一个唯一的标识来标记它，不同的物品具有不同的标识。我们先拿物理空间里面的物品举例，在理想情况下，所有的物品都应该在同一个时空里面，这样大家都能观察的到，并且方便做区分和标识。但是现实情况是，不同的物品可能存在于不同的时空里面，并且观察者也不一定能看到每一个物品。同样的情况，在虚拟资产世界，因为存在不同的账本或称区块链网络(简称域)，不同的物品在同一个域里面因为有不同的标识，可以容易的区分和定位，但是该域里面的观察者无法识别和解析来自外部域的物品标识。</p>
<p>目前现有的很多通证标准的设计，都主要是针对域内资产进行标识设计，没有将不同域内的资产复用考虑进来，这样导致在对非同质资产进行复用时，单独的Token ID无法标识唯一的资产，还需要带上很多域信息，实现起来十分复杂。</p>
<p>跨链技术可以极大的帮助通证在更广泛的区块链网络中实现互联互通，但是同时，也给开发者和用户带来了一些认知和使用门槛，其中就包括通证可识别性的问题。</p>
<p>因为目前的通证标准，例如ERC20或ERC721，只记录的其在某个特定链上的所有权信息，没有考虑到通证有可能会分布在两个区块链网络。当通证同时分布在两个区块链网络时，我们需要一套识别和解析系统帮助用户和通证应用来解析和查询当前的通证状态。当我们给出一个NFT的Token ID时，我们无法确定它目前所在区块链网络是哪个，其所有者是谁，因为当NFT发生跨链转移后，在其中一个区块链网络上该通证处于活跃状态，而其他则处于不可用状态，比如锁定状态。在没有通证解析系统的情况下，链外操作无法确定该NFT在哪条链上时处于活跃状态。</p>
<p>跨链环境下，Token面临的识别性和解析问题，需要新的解决方案和标准来解决。因此我们引入一个基于通证跨链证明的解析系统来解决通证跨链时的定位和解析需求，通过通证解析系统和域内唯一标识，我们可以存在与不同域的通证之间的关联关系映射起来，并标识他们之间的相同与不同。</p>
<p>本文将在<a href="rfcs/./0010-darwinia-cross-chain-nft-bridge-protocol.html">RFC-0010 Darwinia Cross-chain NFT Bridge Protocol</a>的基础上，进一步细化NFT相关的标准和设计细节。</p>
<h2><a class="header" href="#ii-介绍" id="ii-介绍">II. 介绍</a></h2>
<h3><a class="header" href="#a-目标" id="a-目标">A. 目标</a></h3>
<ul>
<li>可识别。NFT在跨链过程中，应该保证NFT的token id可被追溯。因为不同区块链的token id表示的类型不同，所以NFT在不同区块链之间流转的过程中，token id的内容和类型都可能会发生变化；甚至同一个NFT在从chain A跨到chain B，再从chain B跨回chain A后，在chain A上的token id也可能会发生变化，token id的不可识别直接导致资产价值归零。因此与fungible token不同的是，保持NFT的可识别性是NFT跨链安全的重要部分。</li>
<li>可追踪。因为NFT在跨链过程中，token id会不断发生变化，因此了解同一个NFT在不同链上的token id可以对应用层的建立更加复杂的逻辑提供极大的帮助。</li>
<li>访问友好。鉴于需要和外部的钱包/RPC客户端交互，因此减少外部访问的成本，提高效率和友好性也是NFT跨链中的重要内容。在 <a href="https://github.com/darwinia-network/rfcs/blob/master/RFC/zh_CN/0010-darwinia-cross-chain-nft-bridge-protocol.md">0010-darwinia-cross-chain-nft-bridge-protocol</a> 实现方案中，随着NFT在Bridge Core内流转的次数越多，在Bridge Core内沉淀的信息也就越多。因此外部钱包/RPC客户端只需要向Bridge Core请求一次，就可以得到该NFT在所有链的local token id 信息。而不需要向每条链分别请求获取。</li>
</ul>
<h3><a class="header" href="#b-术语" id="b-术语">B. 术语</a></h3>
<ul>
<li><strong>GID / Global ID</strong>， 表示NFT在所有链中的全局唯一标识。适用范围：全局</li>
<li><strong>Local ID / Local token id</strong>，表示NFT在不同的区块链中的token id. 适用范围：某一条区块链</li>
</ul>
<h3><a class="header" href="#c-分类" id="c-分类">C. 分类</a></h3>
<p>当我们讨论NFT跨链时，可以根据NFT所在基础设施的网络情况，分成几类：</p>
<ul>
<li>跨平行链(Polkadot内)</li>
</ul>
<p>当在平行链之间进行跨链时，例如在Polkadot网络中，因为有共享安全，共享运行时SPREE等设计，因此将通证解析系统放在中继链上时最合适的，因为通证跨平行链的消息会流经中继链，中继链可以通过在消息中继模块之外，嵌入一个收集模块，将通证跨链消息规范化统一收集之后，提供给通证解析服务。</p>
<ul>
<li>跨异构公链</li>
</ul>
<p>在异构跨链模式下，例如Ethereum和EOS之间，或者Ethereum和Tron之间，通证跨链一般通过跨链转接桥的方案等进行跨链，例如ACCS(HTLCs), XClaim, Parity Bridge(Mainet/Sidechain)，Darwinia Bridge Core等等。</p>
<p>对基于Darwinia Bridge Core技术搭建的跨链转接桥，其NFT的跨链是通过在对手链上构建超额抵押的对称CBA，并利用Chain Relay技术来保证可赎回性和可解析性。Darwinia Bridge Core跟其他转接桥技术的区别有两点，1. 背书链也支持Chain Relay以更好的验证外链证明，而不需要担保质押 2. 通过在不同的公链上构建Darwinia Chain Relay，并利用一个Hub结构来优化利用这些基础设施，实现公链间的互联互通。设计细节可以参考RFC0010.</p>
<p>本文所讨论的NFT跨链标准，主要集中的Polkadot内部，也就是平行链之间的NFT跨链标准，而对于公链间的跨链桥细节和外部公链上的NFT标准则不包含在本文范围。</p>
<h2><a class="header" href="#iii-跨链共享标准" id="iii-跨链共享标准">III. 跨链共享标准</a></h2>
<h3><a class="header" href="#a-全局唯一标识gid和local-id" id="a-全局唯一标识gid和local-id">A. 全局唯一标识GID和Local ID</a></h3>
<p>鉴于NFT跨链的目标，本方案会在跨链时为NFT分配一个唯一个全局ID，并且在跨链桥内部保留其在外部链上的local token id，达到可识别、可追踪、访问友好的目标。</p>
<p>（跨链桥Bridge Core的实现细节详见<a href="https://github.com/darwinia-network/rfcs/blob/master/RFC/zh_CN/0010-darwinia-cross-chain-nft-bridge-protocol.md">0010-darwinia-cross-chain-nft-bridge-protocol</a>）[1]</p>
<p>为了将不同标准的通证标识符进行规范化，以提供识别和解析方法，与现有的标准进行很好的协调和对接，并满足社区基础设施建设的标准需求。跨链系统将为每一个跨链后的通证分配一个全局ID(global_id)。</p>
<h4><a class="header" href="#gid生成方式" id="gid生成方式">GID生成方式</a></h4>
<p>GID 作为 NFT的全局标识，需要保证唯一性。因此不同的NFT在跨链时为其通过自增的方式分配一个GID即可。</p>
<h4><a class="header" href="#cid-based-local-id-编码方式" id="cid-based-local-id-编码方式">CID-based Local ID 编码方式</a></h4>
<p><strong>Local ID</strong> 为了保证其跨链可识别性，需包含一下三个字段：</p>
<pre><code class="language-python">&lt;chain id&gt;&lt;contract id&gt;&lt;token id&gt;
</code></pre>
<p>不同的区块链的数据类型不同、加密方式等都不相同，因此local token id很可能从内容到类型都差别很大。</p>
<p>这里，我们借鉴IPLD[2]中CID的编码方式。鉴于IPLD用来解决不同区块链上的内容寻址问题，因此也非常适合用来解决这里的local token id的索引问题。</p>
<pre><code class="language-python">&lt;mbase&gt;&lt;version&gt;&lt;chain id&gt;&lt;data&gt;
</code></pre>
<p>解释：</p>
<ul>
<li>
<p><strong>mbase</strong>: 编码方式，base58,base64 etc.</p>
</li>
<li>
<p><strong>version</strong>: 版本信息。</p>
</li>
<li>
<p><strong>chain id</strong>: chain id信息</p>
</li>
<li>
<p><strong>data</strong>： 包含以下两个字段</p>
<pre><code class="language-python">&lt;contract id&gt;&lt;token id&gt;
</code></pre>
<p>contract id 和 token id 又遵从以下格式：</p>
<pre><code class="language-python">&lt;hash func&gt;&lt;len&gt;&lt;value&gt;
</code></pre>
<p>因此完整的data字段如下：</p>
<pre><code class="language-python">&lt;hash func&gt;&lt;len&gt;&lt;contract id content&gt;&lt;hash func&gt;&lt;len&gt;&lt;token id content&gt;
</code></pre>
</li>
</ul>
<p>通过这种编码方式，既可以清晰地寻址到 local token id，又节省了字节数，提高了传输效率。</p>
<h3><a class="header" href="#b-utlilising-fungiblenon-fungible-assets-on-polkadot" id="b-utlilising-fungiblenon-fungible-assets-on-polkadot">B. Utlilising Fungible/Non-fungible assets on Polkadot</a></h3>
<p>基于已有的polkadot内部fungible asset的标识和使用方案[3]进行扩展，我们可以使用如下一行URI格式的标识方式，为钱包/ RPC客户端的访问提供便利：</p>
<p>同一个NFT资产可以用：</p>
<pre><code class="language-html">polkadot://&lt;nft|ft flag&gt;/&lt;Local ID&gt;
</code></pre>
<p>可以用：</p>
<pre><code class="language-python">polkadot://&lt;nft|ft flag&gt;/&lt;Global ID&gt;/&lt;chain ID&gt;
</code></pre>
<p>来表示。</p>
<blockquote>
<p>其中nft|ft flag, 0表示fungible token, 1 表示  non-fungible token</p>
</blockquote>
<p>举例：假设<code>z43AaGEvwdfzjrCZ3Sq7DKxdDHrwoaPQDtqF4jfdkNEVTiqGVFW</code>表示以太坊上合约为<code>0x14a4123da9ad21b2215dc0ab6984ec1e89842c6d</code>，token id为<code>0x01</code>的NFT，它对应的GID为<code>42</code>，那么</p>
<pre><code class="language-python">polkadot://1/z43AaGEvwdfzjrCZ3Sq7DKxdDHrwoaPQDtqF4jfdkNEVTiqGVFW
</code></pre>
<p>表示，也可以用：</p>
<pre><code class="language-python">polkadot://1/42/eth
</code></pre>
<p>表示。</p>
<p>这两个URI会寻址到同一个NFT. 因为Bridge Core已经提供了GID和Local ID间的关系拓扑</p>
<h3><a class="header" href="#c-数据请求格式" id="c-数据请求格式">C. 数据请求格式</a></h3>
<p>如果有钱包/RPC客户端向Bridge Core请求NFT的拓扑信息，可以根据GID得到所有已知链的local ID信息：</p>
<pre><code class="language-html">{
	GID: 42,
	total: [
		{
			chain_id: eth,
		  contract_id: 0x1234,
			token_id: 0x01
     },
		{
			chain_id: eos,
			asset_id: dgoods,
			token_id: 1.2.3
		},
	  ...
	]
}
</code></pre>
<h3><a class="header" href="#d-基于unfo的解析模块" id="d-基于unfo的解析模块">D. 基于UNFO的解析模块</a></h3>
<p>通证解析模块是NFT cross-chain协议内嵌的一个模块，用于在 <em>Issuing chain</em> 或者其连接的中继链上记录和解析当前通证在中继链范围内的全局状态，并规范化处理成解析格式的方式，来为跨链网络提供通证解析查询和可追踪性。由于在NFT跨链桥协议中，使用了UNFO来记录与NFT相关的跨链信息，协议和其他映射信息，因此我们可以利用这些证明信息，并引入NFT解析模块来记录、更新和解析UNFO及相关信息。</p>
<p>在NFT通过Bridge Core 从B链转移至I链的过程中，Bridge Core会为每一个NFT分配一个GID，并将中间状态及其转移过程表达成UNFO，包括GID, (External Chain ID, External Contact Address, External Token ID), lock_script等信息。</p>
<p>这些UNFO记录集合会被归集在一个记录解析表里面，通过这个解析表，可以为跨链协议(e.g redeem)提供NFT通证解析服务，也可以为外部系统提供NFT解析服务。</p>
<table><thead><tr><th>UNFO</th><th>GID</th><th>Externl Chain ID</th><th>External Contact Address</th><th>External Token ID</th><th>Lock_Script</th><th>Active Status</th></tr></thead><tbody>
<tr><td>1</td><td>GID0001</td><td>Ethereum</td><td>A_ERC721</td><td>12</td><td>script_issuing_burn_or_relay</td><td>False</td></tr>
<tr><td>2</td><td>GID0001</td><td>Tron</td><td>B_TRC721</td><td>?</td><td>script_backing_redeem</td><td>True</td></tr>
<tr><td>3</td><td>GID0002</td><td>EOS</td><td>C_dGoods</td><td>2.5.4</td><td>script_issuing_burn_or_relay</td><td>False</td></tr>
<tr><td>4</td><td>GID0002</td><td>EOS</td><td>C_dGoods</td><td>2.5.4</td><td>script_ownership_contract</td><td>True</td></tr>
<tr><td>5</td><td>GID0003</td><td>Bridge Core</td><td>None</td><td>None</td><td>script_ownership_contract</td><td>True</td></tr>
<tr><td>6</td><td>GID0004</td><td>ETC</td><td>ETC_ERC721</td><td>23</td><td>script_issuing_burn_or_relay</td><td>False</td></tr>
<tr><td>7</td><td>GID0004</td><td>Ethereum</td><td>D_ERC1155</td><td>13</td><td>script_backing_redeem</td><td>False</td></tr>
</tbody></table>
<p>GID0001: This NFT is cross-chain transfered from (Ethereum, A_ERC721, 12) to (Tron, B_TRC721, ?) trough Bridge Core, Currently it is active on Tron.</p>
<p>GID0002: This NFT is cross-chain transfered from (EOS, C_dGoods, 2.5.4) to an account Bridge Core,the script_ownership_contract is linking to an ownership managemetn contract on Bridge Core.</p>
<p>GID0003: This NFT is originally created on Bridge Core, it is recorded as UNFO because the golobal identifier is generated in the UNFO module, the script_ownership_contract is linking to an ownership managemetn contract on Bridge Core.</p>
<p>GID0004: This NFT is cross-chain transfered from (ETC, ETC_ERC721, 23) to (Ethereum, D_ERC1155, ?) trough Bridge Core, and then redeem reversely back. The 7th UNFO's External Local ID is unknow before redeem, but when redeeming, it will be updated to reveal it's value.</p>
<center>Figure: UNFO Set Table Sample</center>
备注: 
<ol>
<li>External Token ID有可能是未知状态，用&quot;?&quot;表示，之所以会出现这种情况，是因为在issue过程中, 目标发行链上生成的External Token ID 不会通知和反馈给Bridge Core，没有相关的交易证明信息，UNFO也就只好设置该值为未知。但是，当后面某些新的赎回交易发生时，发起者发送给Bridge Core的赎回交易有可能会包含GID和External Token ID，此时可以通过这个交易证明，更新原来未知的External Token ID值为已知值。</li>
<li>为了保持良好的一致性，在NFT通过Bridge Core跨链流转的生命周期内，希望保持External Chain ID和 (External Contact Address, External Token ID) 的映射关系保持不变，此时可以通过上面提到的解析服务，至历史UNFO记录里面查询相应的External Token ID，以保持一致性。</li>
</ol>
<h3><a class="header" href="#e-跨平行链操作" id="e-跨平行链操作">E. 跨平行链操作</a></h3>
<p>在稍后的III章节，我们将会假设转账是发生在同一条链上的，关于如何处理跨链间的转账，我们将会使用一个关联的SPREE模块来解决(参考Polkadot相关方案[3]实现)。</p>
<p>通证解析系统还可以设计一个关联的SPREE模块(共享存储和共享运行时)，这样可以把解析模块当做一个共享的模块，开放给其他平行链来使用。SPREE模块还可以帮助在解析模块内定义约束条件，例如全局的通证总量，发行规则，并部署至SPREE模块，可以实现中继网络管辖范围的验证和可信互操作。</p>
<h2><a class="header" href="#iv-nft-standard-on-polkadotdarwinia" id="iv-nft-standard-on-polkadotdarwinia">IV. NFT Standard on Polkadot/Darwinia</a></h2>
<p>A cross-chain non fungible token standard is required for blockchains to transfer assets across the ecosystem and for clients (e.g. wallet, browser extension) to offer unified support of the token that provided by different chains.</p>
<p>将参考以太坊中的ERC721和ERC1155标准。所有权管理模块或者合约将直接使用GID作为NFT通证的ID，而GID是由UNFO模块中负责管理和生成的，这一点跟ERC721不同，因为在ERC721中，NFT合约负责管理和生成NFT 的Token ID。</p>
<p>NFT标准主要由几部分组成，GID管理、资源描述、所有权管理、扩展标准。</p>
<h3><a class="header" href="#a-nft-descriptions" id="a-nft-descriptions">A. NFT Descriptions</a></h3>
<p>NFT descriptions offers a universal way to describe, display the details about a token. This information may not be stored on-chain to reduce usage of on-chain storages. A centralized or decentralized token registry may be used to discovery the token description, which is out of the scope here.</p>
<h3><a class="header" href="#b-所有权管理" id="b-所有权管理">B. 所有权管理</a></h3>
<p>[WIP]</p>
<h3><a class="header" href="#c-规范" id="c-规范">C. 规范</a></h3>
<p>[WIP]</p>
<h3><a class="header" href="#参考-4" id="参考-4">参考</a></h3>
<p>[1] https://github.com/darwinia-network/rfcs/blob/master/RFC/zh_CN/0010-darwinia-cross-chain-nft-bridge-protocol.md</p>
<p>[2] https://ipld.io/</p>
<p>[3] https://hackmd.io/gQKQGf42TeOODid3hM4_1w</p>
<p>[4] https://en.wikipedia.org/wiki/Unique_identifier
[5] https://en.wikipedia.org/wiki/Identifiers.org#Comparison_with_other_URI_systems
[6] https://elixir-europe.org/platforms/interoperability</p>
<h1><a class="header" href="#0014" id="0014">0014</a></h1>
<blockquote>
<p>Darwinia Token Migration By Cross-chain Redeem Protocol</p>
</blockquote>
<h2><a class="header" href="#i-概述-2" id="i-概述-2">I. 概述</a></h2>
<p>在Darwinia主网上线之前，已经有一部分RING/KTON资产以ERC20或TRC20的形式存在于以太坊网络或者波场网络之中。从资产跨链的角度来看，因为RING和KTON是被定义成Darwinia 网络的原生资产，因此这些ERC20 Token本质上是以某种形式跨链到以太坊网络上的，也可以理解为CBA (Cryptocurreny Backed Assets)，也就是说，每个ERC-20 RING都有相应的RING被锁定在Darwinia 主网上面，在主网上线之前，相应的背书资产即存在于创世块(Genesis)中。</p>
<p>RING和KTON的ERC20 Token信息:</p>
<ul>
<li>RING Token Address: https://etherscan.io/token/0x9469d013805bffb7d3debe5e7839237e535ec483</li>
<li>KTON Token Address: https://etherscan.io/token/0x9f284e1337a815fe77d2ff4ae46544645b20c5ff</li>
</ul>
<p>本文将在<a href="rfcs/./0012-darwinia-bridge-core-interoperation-in-chainrelay-enabled-blockchains.html">RFC-0012: Darwinia Bridge Core: Interoperation in ChainRelay Enabled Blockchains</a>的基础上，讨论Darwinia主网上线后，ERC-20形式的RING如何赎回至Darwinia网络，以及如何借助于Darwinia 转接桥的设计，Token将如何在Darwinia主网及其他公链中进行流转。</p>
<h2><a class="header" href="#ii-介绍-1" id="ii-介绍-1">II. 介绍</a></h2>
<h3><a class="header" href="#a-设计范围-1" id="a-设计范围-1">A. 设计范围</a></h3>
<ul>
<li>Darwinia原生资产RING/KTON跨链设计。主要描述如何应用ERC-0012及相关跨链互操作协议，帮助RING/KTON实现在Darwinia网络和其他支持智能合约的网络(例如，以太坊、TRON、EOS)之间流转</li>
<li>创世块中管理背书资产。当Darwinia主网上线时，目前以ERC20/TRC20形式存在的RING/KTON对应的原生资产将会记录在创世块之中，并被背书管理模块锁定，用于支持后续外部资产的赎回。</li>
<li>背书管理模块的其他主要功能。背书管理模块还将满足主网上线后其他的跨链转账需求，例如后续用户如何将主网上的RING/KTON原生资产跨链到以太坊上。其发行出来的ERC20代币(代表CBA)将与现有的RING/KTON合约共享同一个ERC-20智能合约。</li>
<li>外部链的发行合约和chain relay。这部分方案的可行性依赖于chain relay的实现方案，主要是如何在以太坊上实现一个低成本可持续运行的Darwinia Chain Relay，这部分的细节不在此处描述，具体可参考 RFV-0012 VI章节。在以太坊实现了一个Darwinia Chain Relay的基础之上，外部链需要新增一个发型管理合约(Issuing Contract)用于接受Darwinia上的跨链转账交易证明，并通过Darwinia Chain Relay进行验证（包括交易存在证明，共识证明，交易内容证明等），在验证通过之后，进行相关的RING/KTON发行。这部分属于高级功能，其开发和实现可以独立于背书模块中的迁移功能，在最开始，可以先只支持单向的以太坊至Darwinia的赎回功能。</li>
<li>Gringotts合约的停止和存单迁移协议</li>
</ul>
<h3><a class="header" href="#b-术语-1" id="b-术语-1">B. 术语</a></h3>
<ul>
<li><strong>Genesis</strong>， 创世块或表示区块链网络创世状态的账本数据。</li>
<li><strong>CBA</strong>, 全称Cryptocurrency Backed Assets, 即有加密资产背书的资产，详细介绍可以参考XClaim <a href="https://github.com/darwinia-network/rfcs/raw/master/RFC/zh_CN/images/darwinia_deposit_migration_protocol.png">1</a>.</li>
<li><strong>Chain Relay</strong>,  Cross-Chain State Verification. It is capable of interpreting the statte of the backing blockchain B and provide functionality comparable to an SPV or light client. 主要用于验证外部区块链网络的交易存在性证明和共识证明。</li>
<li><strong>Backing Contract/Module</strong>，Backing Blockchain中用于管理背书资产的合约或者模块，包括锁定和释放等功能，在Darwinia网络中Backing Module还负责管理锁定在创世块中的背书资产。</li>
<li><strong>Chain Relay Module</strong>, 实现在Darwinia上的针对外部区块链网络(例如Ethereum/ Tron)的Chain Relay.</li>
<li><strong>External Darwinia Chain Relay</strong>，存在于外部区块链网络上的针对Darwinia Network的Chain Relay.</li>
<li><strong>External Issuing Contract</strong>, 用于在外部区块链网络中发行原生RING/KTON CBA的ERC-20 Token.</li>
</ul>
<h3><a class="header" href="#c-背书资产genesis配置" id="c-背书资产genesis配置">C. 背书资产Genesis配置</a></h3>
<p>在Darwinia主网上线之时，就存在CBA背书资产，因此需要将RING/KTON在其他链上的资产背书信息定义在Genesis Config中，当主网上线之后，这些背书资产将会初始化相应原生资产，并将其锁定在背书合约中，供特殊赎回(迁移)协议使用。</p>
<p>需要注意的是，Genesis Config总分发和锁定的RING/KTON，将对应于主网上线时对应公链上RING/KTON的Total Supply. </p>
<p>Genesis Config 片段示例:</p>
<pre><code class="language-json">{
  &quot;backingAssets&quot;: {
    &quot;Ethereum&quot; : {
      &quot;RING&quot; : 100000,
      &quot;KTON&quot; : 50000
    },
    &quot;Tron&quot; : {
      &quot;RING&quot; : 3000,
      &quot;KTON&quot; : 200
    }
  }
}
</code></pre>
<h3><a class="header" href="#iii-通过特殊赎回协议实现ringkton迁移" id="iii-通过特殊赎回协议实现ringkton迁移">III. 通过特殊赎回协议实现RING/KTON迁移</a></h3>
<p>当用户需要将ERC-20形式的RING通证转化成Darwinia主网上的RING的时候，其只需要将该部分RING发送一个Token销毁合约，在确认销毁成功之后，用户将该笔交易证明发送给Darwinia网路的解锁合约，解锁合约在验证完成之后，将会从背书资产模块中释放对应的RING通证给赎回者。</p>
<p><img src="https://github.com/darwinia-network/rfcs/raw/master/RFC/zh_CN/images/darwinia_token_migration_protocol.png" alt="Darwinia Token Migration Protocol" /></p>
<h4><a class="header" href="#a-与普通赎回协议的区别" id="a-与普通赎回协议的区别">A. 与普通赎回协议的区别</a></h4>
<p>RING/KTON特殊赎回协议跟Darwinia Bridge Core中的普通赎回协议最大的区别在于背书资产(Backing Assets)。普通赎回协议中需要赎回的背书资产，都是之前通过发行协议锁定在Backing Contract里面的，但是在RING/KTON特殊赎回协议这里并没有先前的锁定发行CBA的过程，主网上线前的ERC20 RING对应的Backing Assets是通过创始块背书，进行分发和锁定。</p>
<p>创始块中锁定的原生资产用于支持原本已经在其他公链(Ethereum和Tron)上已经存在的ERC20形式的RING/KTON赎回功能。当用户需要拿回Darwinia主链上的原生背书资产时，他们只需要按照特殊赎回协议销毁背书资产对应的RING/KTON CBA Token就可以了。</p>
<h4><a class="header" href="#b-chain-relay-srml模块" id="b-chain-relay-srml模块">B. Chain Relay SRML模块</a></h4>
<p>Chain Relay是实现Token跨链转接桥的关键模块，类似于一个支持SPV的轻客户端。在像以太坊这样的智能合约公链中，Chain Relay是用智能合约来实现的，例如<a href="https://github.com/ethereum/btcrelay">BTCRelay</a>。对于Darwinia来说，因为是基于Substrate开发，支持SRML模块和链上升级，所以就多了一个选择，可以将Chain Relay的实现为Darwinia的一个SRML，并针对不同的公链实现不同的SRML形式的Chain Relay，以提供相应公链的跨链支持。</p>
<p>对于具体的实现，性能和成本是非常重要的考量，因此需要基于一些改进方案来帮助实现，相关改进方案在RFC-0012 VI章节详细描述。</p>
<h4><a class="header" href="#c-gringotts合约的停止和存单迁移协议" id="c-gringotts合约的停止和存单迁移协议">C. Gringotts合约的停止和存单迁移协议</a></h4>
<p>Gringotts合约实现:</p>
<p>https://github.com/evolutionlandorg/bank</p>
<p>Gringotts合约功能中存RING得KTON的功能对应于Darwinia Staking 模块中的承诺锁定得KTON的功能，Darwinia主网上线后，这部分功能将从以太坊(或波场)Gringotts智能合约迁移至Darwinia主网。</p>
<p>为了保证主网上线时和之后，其他公链上不会有新的KTON被通过定期存RING发行出来，因此，主网上线前Gringott合约功能将停止存RING得KTON功能，但是RING取回功能仍将保留。</p>
<p>此外，因为Gringotts存单中锁定了RING，而这部分RING的持有者可能希望参与到Darwinia Staking中去，因此需要支持Gringotts存单迁移的功能，主要包括以下几个步骤(以太坊为例):</p>
<ul>
<li>
<p>将存单以及存单中的RING一起销毁，销毁交易中需要包含存单ID，锁定RING的数量，存单到期时间等关键参数证明，销毁合约将会对这些关键参数进行比对和校验，通过之后销毁存单的RING Token。这样只需要证明交易被打包和存在，就可以从交易中解析出这些关键参数，并保证这些参数的正确性。</p>
</li>
<li>
<p>迁移者在确定这笔交易的成功和Finalization之后，将这个交易证明提交给Darwinia的存单迁移模块。</p>
</li>
<li>
<p>Darwinia的存单迁移模块在验证交易的正确性之后，将进行Darwinia上的剩余迁移步骤，包括a)对应数量RING的解锁，b)将这些RING进行Staking. c) 对这些Staking的RING进行承诺锁定.(区别于正常流程，这里不会有KTON奖励被发行，因为在以太坊中已经奖励过了)</p>
<p><img src="https://github.com/darwinia-network/rfcs/raw/master/RFC/zh_CN/images/darwinia_deposit_migration_protocol.png" alt="Gringotss Deposit Migration Protocol" /></p>
</li>
</ul>
<h3><a class="header" href="#iv-跨链转账的普通发行和普通赎回协议" id="iv-跨链转账的普通发行和普通赎回协议">IV. 跨链转账的普通发行和普通赎回协议</a></h3>
<p>对于Darwinia 来说，不仅仅存在主网上线后的Token迁移需求，还存在将主网上原生的RING/KTON资产跨链到其他公链的需求。因此以太坊上的ERC-20 RING不仅可以通过迁移协议单向回到Darwinia，也可以继续保留在以太坊上面，而且Darwinia上的RING还可以通过跨链转接桥作为CBA发行到以太坊上面成为ERC-20 RING，这个过程将由普通发行和赎回协议完成，其协议流程和设计跟正常的Token跨链协议一样，没有太大区别。</p>
<h2><a class="header" href="#参考-5" id="参考-5">参考</a></h2>
<ol>
<li>XClaim, https://eprint.iacr.org/2018/643.pdf</li>
<li>FlyClient, https://eprint.iacr.org/2019/226.pdf</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
